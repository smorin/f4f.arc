<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text-html; charset=utf-8" /><title>3&nbsp;Memory Allocation</title><link rel="stylesheet" type="text/css" href="../scribble.css" title="default" /><link rel="stylesheet" type="text/css" href="../racket.css" title="default" /><link rel="stylesheet" type="text/css" href="../scribble-style.css" title="default" /><script type="text/javascript" src="../scribble-common.js"></script></head><body id="doc-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist" style="margin-bottom: 1em;"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" pltdoc="x"><span style="font-weight: bold">Inside</span>:<span class="mywbr"> </span> Racket C API</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="overview.html" class="tocviewlink" pltdoc="x">Overview</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="im_values_types.html" class="tocviewlink" pltdoc="x">Values and Types</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="" class="tocviewselflink" pltdoc="x">Memory Allocation</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="im_env.html" class="tocviewlink" pltdoc="x">Namespaces and Modules</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="Procedures.html" class="tocviewlink" pltdoc="x">Procedures</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="Evaluation.html" class="tocviewlink" pltdoc="x">Evaluation</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="exceptions.html" class="tocviewlink" pltdoc="x">Exceptions and Escape Continuations</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="threads.html" class="tocviewlink" pltdoc="x">Threads</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="config.html" class="tocviewlink" pltdoc="x">Parameterizations</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="contmarks.html" class="tocviewlink" pltdoc="x">Continuation Marks</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="im_encodings.html" class="tocviewlink" pltdoc="x">String Encodings</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="Bignums__Rationals__and_Complex_Numbers.html" class="tocviewlink" pltdoc="x">Bignums, Rationals, and Complex Numbers</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="Ports_and_the_Filesystem.html" class="tocviewlink" pltdoc="x">Ports and the Filesystem</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="Structures.html" class="tocviewlink" pltdoc="x">Structures</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="security.html" class="tocviewlink" pltdoc="x">Security Guards</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="Custodians.html" class="tocviewlink" pltdoc="x">Custodians</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="Miscellaneous_Utilities.html" class="tocviewlink" pltdoc="x">Miscellaneous Utilities</a></td></tr><tr><td align="right">18&nbsp;</td><td><a href="Flags_and_Hooks.html" class="tocviewlink" pltdoc="x">Flags and Hooks</a></td></tr><tr><td align="right"></td><td><a href="doc-index.html" class="tocviewlink" pltdoc="x">Index</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>3&nbsp;</td><td><a href="" class="tocviewselflink" pltdoc="x">Memory Allocation</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">3.1&nbsp;</td><td><a href="#(part._im~3a3m)" class="tocviewlink" pltdoc="x">Cooperating with 3m</a></td></tr><tr><td align="right">3.2&nbsp;</td><td><a href="#(part._.Memory_.Functions)" class="tocviewlink" pltdoc="x">Memory Functions</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#(part._im~3a3m)" class="tocsubseclink" pltdoc="x">Cooperating with 3m</a></td></tr><tr><td><span class="tocsublinknumber">3.1.1<tt>&nbsp;</tt></span><a href="#(part._im~3a3m~3atagged)" class="tocsubseclink" pltdoc="x">Tagged Objects</a></td></tr><tr><td><span class="tocsublinknumber">3.1.2<tt>&nbsp;</tt></span><a href="#(part._im~3a3m~3astack)" class="tocsubseclink" pltdoc="x">Local Pointers</a></td></tr><tr><td><span class="tocsublinknumber">3.1.3<tt>&nbsp;</tt></span><a href="#(part._im~3a3m~3amzc)" class="tocsubseclink" pltdoc="x">Local Pointers and <span class="stt">raco ctool</span> <span class="nobreak"><span class="stt">-<wbr></wbr>-<wbr></wbr>xform</span></span></a></td></tr><tr><td><span class="tocsublinknumber">3.1.4<tt>&nbsp;</tt></span><a href="#(part._im~3a3m~3amacros)" class="tocsubseclink" pltdoc="x">Guiding <span class="stt">raco ctool</span> <span class="nobreak"><span class="stt">-<wbr></wbr>-<wbr></wbr>xform</span></span></a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#(part._.Memory_.Functions)" class="tocsubseclink" pltdoc="x">Memory Functions</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><form class="searchform"><input class="searchbox" style="color: #888;" type="text" value="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;5.0.2&quot;, &quot;../&quot;);" onfocus="this.style.color=&quot;black&quot;; this.style.textAlign=&quot;left&quot;; if (this.value == &quot;...search manuals...&quot;) this.value=&quot;&quot;;" onblur="if (this.value.match(/^ *$/)) { this.style.color=&quot;#888&quot;; this.style.textAlign=&quot;center&quot;; this.value=&quot;...search manuals...&quot;; }" /></form>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" pltdoc="x" onclick="return GotoPLTRoot(&quot;5.0.2&quot;);">top</a></span><span class="navright"><a href="im_values_types.html" title="backward to &quot;2 Values and Types&quot;" pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Inside: Racket C API&quot;" pltdoc="x">up</a>&nbsp;&nbsp;<a href="im_env.html" title="forward to &quot;4 Namespaces and Modules&quot;" pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>3<tt>&nbsp;</tt><a name="(part._im~3amemoryalloc)"></a><a name="(idx._(gentag._202._(lib._scribblings/inside/inside..scrbl)))"></a><a name="(idx._(gentag._203._(lib._scribblings/inside/inside..scrbl)))"></a>Memory Allocation</h3><p>Racket uses both <span class="stt">malloc</span> and allocation functions provided
by a garbage collector. Embedding/extension C/C++ code may use either
allocation method, keeping in mind that pointers to
garbage-collectable blocks in <span class="stt">malloc</span>ed memory are invisible
(i.e., such pointers will not prevent the block from being
garbage-collected).</p><p>Racket CGC uses a conservative garbage collector.  This garbage
collector normally only recognizes pointers to the beginning of
allocated objects. Thus, a pointer into the middle of a GC-allocated
string will normally not keep the string from being collected. The
exception to this rule is that pointers saved on the stack or in
registers may point to the middle of a collectable object.  Thus, it
is safe to loop over an array by incrementing a local pointer
variable.</p><p>Racket 3m uses a precise garbage collector that moves objects
during collection, in which case the C code must be instrumented to
expose local pointer bindings to the collector, and to provide tracing
procedures for (tagged) records containing pointers. This
instrumentation is described further in <a href="#(part._im~3a3m)" pltdoc="x">Cooperating with 3m</a>.</p><p>The basic collector allocation functions are:</p><ul><li><p><a href="#(cpp._scheme_malloc)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc</span></a>  &ndash;  Allocates collectable memory that may
contain pointers to collectable objects; for 3m, the memory must be
an array of pointers (though not necessarily to collectable
objects). The newly allocated memory is initially zeroed.</p></li><li><p><a href="#(cpp._scheme_malloc_atomic)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_atomic</span></a>  &ndash;  Allocates collectable memory
that does not contain pointers to collectable objects. If the memory
does contain pointers, they are invisible to the collector and will
not prevent an object from being collected. Newly allocated atomic
memory is not necessary zeroed.</p><p>Atomic memory is used for strings or other blocks of memory which do
not contain pointers. Atomic memory can also be used to store
intentionally-hidden pointers.</p></li><li><p><a href="#(cpp._scheme_malloc_tagged)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_tagged</span></a>  &ndash;  Allocates collectable memory
that contains a mixture of pointers and atomic data. With the
conservative collector, this function is the same
as <a href="#(cpp._scheme_malloc)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc</span></a>, but under 3m, the type tag stored at the
start of the block is used to determine the size and shape of the
object for future garbage collection (as described
in <a href="#(part._im~3a3m)" pltdoc="x">Cooperating with 3m</a>).</p></li><li><p><a href="#(cpp._scheme_malloc_allow_interior)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_allow_interior</span></a>  &ndash;  Allocates a large
array of pointers such that references are allowed into the middle of
the block under 3m, and such pointers prevent the block from being
collected. This procedure is the same as <a href="#(cpp._scheme_malloc)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc</span></a> with
the conservative collector, but in the that case, having <span style="font-style: italic">only</span>
a pointer into the interior will not prevent the array from being
collected.</p></li><li><p><a href="#(cpp._scheme_malloc_atomic_allow_interior)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_atomic_allow_interior</span></a>  &ndash;  Like
<a href="#(cpp._scheme_malloc_allow_interior)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_allow_interior</span></a> for memory that does not
contain pointers.</p></li><li><p><a href="#(cpp._scheme_malloc_uncollectable)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_uncollectable</span></a>  &ndash;  Allocates
uncollectable memory that may contain pointers to collectable
objects. There is no way to free the memory. The newly allocated
memory is initially zeroed. This function is not available in 3m.</p></li></ul><p><a name="(idx._(gentag._204._(lib._scribblings/inside/inside..scrbl)))"></a>If a Racket extension
stores Racket pointers in a global or static variable, then that
variable must be registered with
<a href="#(cpp._scheme_register_extension_global)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_register_extension_global</span></a>; this makes the pointer
visible to the garbage collector. Registered variables need not
contain a collectable pointer at all times (even with 3m, but the
variable must contain some pointer, possibly uncollectable, at all
times).</p><p>With conservative collection, no registration is needed for the global
or static variables of an embedding program, unless it calls
<a href="#(cpp._scheme_main_setup)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_main_setup</span></a> or <a href="#(cpp._scheme_set_stack_base)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_set_stack_base</span></a> with a non-zero
first or second (respectively) argument. In that case, global and
static variables containing collectable pointers must be registered
with <a href="#(cpp._scheme_register_static)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_register_static</span></a>. The <span class="stt">MZ_REGISTER_STATIC</span>
macro takes any variable name and registers it with
<a href="#(cpp._scheme_register_static)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_register_static</span></a>. The <a href="#(cpp._scheme_register_static)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_register_static</span></a>
function can be safely called even when it&rsquo;s not needed, but it must
not be called multiple times for a single memory address.</p><p>Collectable memory can be temporarily locked from collection by using
the reference-counting function <a href="#(cpp._scheme_dont_gc_ptr)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_dont_gc_ptr</span></a>. Under 3m,
such locking does not prevent the object from being moved.</p><p>Garbage collection can occur during any call into Racket or its
allocator, on anytime that Racket has control, except during functions
that are documented otherwise.  The predicate and accessor macros
listed in <a href="im_values_types.html#(part._im~3astdtypes)" pltdoc="x">Standard Types</a> never trigger a collection.</p><h4>3.1<tt>&nbsp;</tt><a name="(part._im~3a3m)"></a>Cooperating with 3m</h4><p>To allow 3m&rsquo;s precise collector to detect and update pointers during
garbage collection, all pointer values must be registered with the
collector, at least during the times that a collection may occur.  The
content of a word registered as a pointer must contain either
<span class="stt">NULL</span>, a pointer to the start of a collectable object, a pointer
into an object allocated by <a href="#(cpp._scheme_malloc_allow_interior)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_allow_interior</span></a>, a
pointer to an object currently allocated by another memory manager
(and therefore not into a block that is currently managed by the
collector), or a pointer to an odd-numbered address (e.g., a Racket
fixnum).</p><p>Pointers are registered in three different ways:</p><ul><li><p>Pointers in static variables should be registered with
<a href="#(cpp._scheme_register_static)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_register_static</span></a> or <span class="stt">MZ_REGISTER_STATIC</span>.</p></li><li><p>Pointers in allocated memory are registered automatically when
they are in an array allocated with <a href="#(cpp._scheme_malloc)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc</span></a>, etc.  When a
pointer resides in an object allocated with
<a href="#(cpp._scheme_malloc_tagged)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_tagged</span></a>, etc.~the tag at the start of the object
identifiers the object&rsquo;s size and shape. Handling of tags is
described in <a href="#(part._im~3a3m~3atagged)" pltdoc="x">Tagged Objects</a>.</p></li><li><p>Local pointers (i.e., pointers on the stack or in registers)
must be registered through the <a href="#(cpp._.M.Z_.G.C_.D.E.C.L_.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_DECL_REG</span></a>, etc. macros
that are described in <a href="#(part._im~3a3m~3astack)" pltdoc="x">Local Pointers</a>.</p></li></ul><p>A pointer must never refer to the interior of an allocated object
(when a garbage collection is possible), unless the object was
allocated with <a href="#(cpp._scheme_malloc_allow_interior)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_allow_interior</span></a>. For this reason,
pointer arithmetic must usually be avoided, unless the variable
holding the generated pointer is <span class="stt">NULL</span>ed before a collection.</p><p><span style="font-weight: bold">IMPORTANT:</span> The <a href="im_values_types.html#(cpp._.S.C.H.E.M.E_.S.Y.M_.V.A.L)" class="RktStxLink" pltdoc="x"><span class="stt">SCHEME_SYM_VAL</span></a>,
<a href="im_values_types.html#(cpp._.S.C.H.E.M.E_.K.E.Y.W.O.R.D_.V.A.L)" class="RktStxLink" pltdoc="x"><span class="stt">SCHEME_KEYWORD_VAL</span></a>, <a href="im_values_types.html#(cpp._.S.C.H.E.M.E_.V.E.C_.E.L.S)" class="RktStxLink" pltdoc="x"><span class="stt">SCHEME_VEC_ELS</span></a>, and
<span class="stt">SCHEME_PRIM_CLOSURE_ELS</span> macros produce pointers into the middle
of their respective objects, so the results of these macros must not
be held during the time that a collection can occur. Incorrectly
retaining such a pointer can lead to a crash.</p><h5>3.1.1<tt>&nbsp;</tt><a name="(part._im~3a3m~3atagged)"></a>Tagged Objects</h5><p>As explained in <a href="im_values_types.html" pltdoc="x">Values and Types</a>, the <a href="im_values_types.html#(cpp._scheme_make_type)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_type</span></a>
function can be used to obtain a new tag for a new type of object.
These new types are in relatively short supply for 3m; the maximum tag
is 255, and Racket itself uses nearly 200.</p><p>After allocating a new tag in 3m (and before creating instances of the
tag), a <span style="font-style: italic">size procedure</span>, a <span style="font-style: italic">mark procedure</span>, and a
<span style="font-style: italic">fixup procedure</span> must be installed for the tag using
<a href="#(cpp._.G.C_register_traversers)" class="RktStxLink" pltdoc="x"><span class="stt">GC_register_traversers</span></a>.</p><p>A size procedure simply takes a pointer to an object with the tag and
returns its size in words (not bytes). The <span class="stt">gcBYTES_TO_WORDS</span>
macro converts a byte count to a word count.</p><p>A mark procedure is used to trace references among objects without
moving any objects. The procedure takes a pointer to an object, and it
should apply the <span class="stt">gcMARK</span> macro to every pointer within the
object.  The mark procedure should return the same result as the size
procedure.</p><p>A fixup procedure is used to update references to objects after or
while they are moved. The procedure takes a pointer to an object, and
it should apply the <span class="stt">gcFIXUP</span> macro to every pointer within the
object; the expansion of this macro takes the address of its
argument. The fixup procedure should return the same result as the
size procedure.</p><p>Depending on the collector&rsquo;s implementation, the mark or fixup
procedure might not be used. For example, the collector may only use
the mark procedure and not actually move the object. Or it may use the
fixup procedure to mark and move objects at the same time. To
dereference an object pointer during a fixup procedure, use
<a href="#(cpp._.G.C_fixup_self)" class="RktStxLink" pltdoc="x"><span class="stt">GC_fixup_self</span></a> to convert the address passed to the procedure to
refer to the potentially moved object, and use <a href="#(cpp._.G.C_resolve)" class="RktStxLink" pltdoc="x"><span class="stt">GC_resolve</span></a> to
convert an address that is not yet fixed up to determine the object&rsquo;s
current location.</p><p>When allocating a tagged object in 3m, the tag must be installed
immediately after the object is allocated &ndash; or, at least, before the
next possible collection.</p><h5>3.1.2<tt>&nbsp;</tt><a name="(part._im~3a3m~3astack)"></a>Local Pointers</h5><p>The 3m collector needs to know the address of every local or temporary
pointer within a function call at any point when a collection can be
triggered. Beware that nested function calls can hide temporary
pointers; for example, in</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">scheme_make_pair(scheme_make_pair(scheme_true, scheme_false),</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_make_pair(scheme_false, scheme_true))</span></span></p></td></tr></table></p><p>the result from one <a href="im_values_types.html#(cpp._scheme_make_pair)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_pair</span></a> call is on the stack or in
a register during the other call to <a href="im_values_types.html#(cpp._scheme_make_pair)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_pair</span></a>; this
pointer must be exposed to the garbage collection and made subject to
update. Simply changing the code to</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp = scheme_make_pair(scheme_true, scheme_false);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">scheme_make_pair(tmp,</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_make_pair(scheme_false, scheme_true))</span></span></p></td></tr></table></p><p>does not expose all pointers, since <span class="stt">tmp</span> must be evaluated before
the second call to <a href="im_values_types.html#(cpp._scheme_make_pair)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_pair</span></a>. In general, the above code
must be converted to the form</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp1 = scheme_make_pair(scheme_true, scheme_false);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp2 = scheme_make_pair(scheme_true, scheme_false);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">scheme_make_pair(tmp1, tmp2);</span></span></p></td></tr></table></p><p>and this is converted form must be instrumented to register <span class="stt">tmp1</span>
and <span class="stt">tmp2</span>. The final result might be</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Object *tmp1 = NULL, *tmp2 = NULL, *result;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_DECL_REG(2);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(0, tmp1);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(1, tmp2);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_REG();</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp1 = scheme_make_pair(scheme_true, scheme_false);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp2 = scheme_make_pair(scheme_true, scheme_false);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">result = scheme_make_pair(tmp1, tmp2);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_UNREG();</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return result;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr></table></p><p>Notice that <span class="stt">result</span> is not registered above. The
<a name="(cpp._.M.Z_.G.C_.U.N.R.E.G)"></a><a name="(idx._(gentag._205._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.M.Z_.G.C_.U.N.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_UNREG</span></a> macro cannot trigger a garbage collection, so the
<span class="stt">result</span> variable is never live during a potential
collection. Note also that <span class="stt">tmp1</span> and <span class="stt">tmp2</span> are initialized
with <span class="stt">NULL</span>, so that they always contain a pointer whenever a
collection is possible.</p><p>The <a name="(cpp._.M.Z_.G.C_.D.E.C.L_.R.E.G)"></a><a name="(idx._(gentag._206._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.M.Z_.G.C_.D.E.C.L_.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_DECL_REG</span></a> macro expands to a local-variable
declaration to hold information for the garbage collector. The
argument is the number of slots to provide for
registration. Registering a simple pointer requires a single slot,
whereas registering an array of pointers requires three slots. For
example, to register a pointer <span class="stt">tmp</span> and an array of 10
<span class="stt">char*</span>s:</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Object *tmp1 = NULL;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">char *a[10];</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int i;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_DECL_REG(4);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_ARRAY_VAR_IN_REG(0, a, 10);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(3, tmp1);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">/* Clear a before a potential GC: */</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">for (i = 0; i &lt; 10; i++) a[i] = NULL;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">...</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">f(a);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">...</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr></table></p><p>The <a name="(cpp._.M.Z_.G.C_.A.R.R.A.Y_.V.A.R_.I.N_.R.E.G)"></a><a name="(idx._(gentag._207._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.M.Z_.G.C_.A.R.R.A.Y_.V.A.R_.I.N_.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_ARRAY_VAR_IN_REG</span></a> macro registers a local array given
a starting slot, the array variable, and an array size. The
<a name="(cpp._.M.Z_.G.C_.V.A.R_.I.N_.R.E.G)"></a><a name="(idx._(gentag._208._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.M.Z_.G.C_.V.A.R_.I.N_.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_VAR_IN_REG</span></a> macro takes a slot and simple pointer variable. A
local variable or array must not be registered multiple times.</p><p>In the above example, the first argument to <a href="#(cpp._.M.Z_.G.C_.V.A.R_.I.N_.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_VAR_IN_REG</span></a> is
<span class="stt">3</span> because the information for <span class="stt">a</span> uses the first three
slots. Even if <span class="stt">a</span> is not used after the call to <span class="stt">f</span>, <span class="stt">a</span>
must be registered with the collector during the entire call to
<span class="stt">f</span>, because <span class="stt">f</span> presumably uses <span class="stt">a</span> until it returns.</p><p>The name used for a variable need not be immediate. Structure members
can be supplied as well:</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">struct { void *s; int v; void *t; } x = {NULL, 0, NULL};</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_DECL_REG(2);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(0, x.s);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(0, x.t);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">...</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr></table></p><p>In general, the only constraint on the second argument to
<a href="#(cpp._.M.Z_.G.C_.V.A.R_.I.N_.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_VAR_IN_REG</span></a> or <a href="#(cpp._.M.Z_.G.C_.A.R.R.A.Y_.V.A.R_.I.N_.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_ARRAY_VAR_IN_REG</span></a> is that
<span class="stt">&amp;</span> must produce the relevant address, and that address must be on
the stack.</p><p>Pointer information is not actually registered with the collector
until the <a name="(cpp._.M.Z_.G.C_.R.E.G)"></a><a name="(idx._(gentag._209._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.M.Z_.G.C_.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_REG</span></a> macro is used. The <a href="#(cpp._.M.Z_.G.C_.U.N.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_UNREG</span></a> macro
de-registers the information. Each call to <a href="#(cpp._.M.Z_.G.C_.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_REG</span></a> must be
balanced by one call to <a href="#(cpp._.M.Z_.G.C_.U.N.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_UNREG</span></a>.</p><p>Pointer information need not be initialized with
<a href="#(cpp._.M.Z_.G.C_.V.A.R_.I.N_.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_VAR_IN_REG</span></a> and <a href="#(cpp._.M.Z_.G.C_.A.R.R.A.Y_.V.A.R_.I.N_.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_ARRAY_VAR_IN_REG</span></a> before
calling <a href="#(cpp._.M.Z_.G.C_.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_REG</span></a>, and the set of registered pointers can change
at any time &ndash; as long as all relevant pointers are registered when a
collection might occur. The following example recycles slots and
completely de-registers information when no pointers are relevant. The
example also illustrates how <a href="#(cpp._.M.Z_.G.C_.U.N.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_UNREG</span></a> is not needed when
control escapes from the function, such as when
<a href="exceptions.html#(cpp._scheme_signal_error)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_signal_error</span></a> escapes.</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Object *tmp1 = NULL, *tmp2 = NULL;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">mzchar *a, *b;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_DECL_REG(2);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(0, tmp1);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(1, tmp2);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp1 = scheme_make_utf8_string("foo");</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_REG();</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp2 = scheme_make_utf8_string("bar");</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp1 = scheme_append_char_string(tmp1, tmp2);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">if (SCHEME_FALSEP(tmp1))</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_signal_error("shouldn't happen!");</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a = SCHEME_CHAR_VAL(tmp1);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(0, a);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp2 = scheme_make_pair(scheme_read_bignum(a, 0, 10), tmp2);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_UNREG();</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">if (SCHEME_INTP(tmp2)) {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return 0;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_REG();</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp1 = scheme_make_pair(scheme_read_bignum(a, 0, 8), tmp2);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_UNREG();</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return tmp1;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr></table></p><p>A <a href="#(cpp._.M.Z_.G.C_.D.E.C.L_.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_DECL_REG</span></a> can be used in a nested block to hold
declarations for the block&rsquo;s variables. In that case, the nested
<a href="#(cpp._.M.Z_.G.C_.D.E.C.L_.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_DECL_REG</span></a> must have its own <a href="#(cpp._.M.Z_.G.C_.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_REG</span></a> and
<a href="#(cpp._.M.Z_.G.C_.U.N.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_UNREG</span></a> calls.</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Object *accum = NULL;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_DECL_REG(1);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(0, accum);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_REG();</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">accum = scheme_make_pair(scheme_true, scheme_null);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Scheme_Object *tmp = NULL;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">MZ_GC_DECL_REG(1);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(0, tmp);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">MZ_GC_REG();</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">tmp = scheme_make_pair(scheme_true, scheme_false);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">accum = scheme_make_pair(tmp, accum);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">MZ_GC_UNREG();</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">accum = scheme_make_pair(scheme_true, accum);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_UNREG();</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return accum;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr></table></p><p>Variables declared in a local block can also be registered together
with variables from an enclosing block, but the local-block variable
must be unregistered before it goes out of scope. The
<a name="(cpp._.M.Z_.G.C_.N.O_.V.A.R_.I.N_.R.E.G)"></a><a name="(idx._(gentag._210._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.M.Z_.G.C_.N.O_.V.A.R_.I.N_.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_NO_VAR_IN_REG</span></a> macro can be used to unregister a variable
or to initialize a slot as having no variable.</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Object *accum = NULL;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_DECL_REG(2);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(0, accum);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_NO_VAR_IN_REG(1);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_REG();</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">accum = scheme_make_pair(scheme_true, scheme_null);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Scheme_Object *tmp = NULL;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(1, tmp);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">tmp = scheme_make_pair(scheme_true, scheme_false);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">accum = scheme_make_pair(tmp, accum);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">MZ_GC_NO_VAR_IN_REG(1);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">accum = scheme_make_pair(scheme_true, accum);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_UNREG();</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return accum;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr></table></p><p>The <span class="stt">MZ_GC_</span> macros all expand to nothing when <span class="stt">MZ_PRECISE_GC</span>
is not defined, so the macros can be placed into code to be compiled
for both conservative and precise collection.</p><p>The <a href="#(cpp._.M.Z_.G.C_.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_REG</span></a> and <a href="#(cpp._.M.Z_.G.C_.U.N.R.E.G)" class="RktStxLink" pltdoc="x"><span class="stt">MZ_GC_UNREG</span></a> macros must never be
used in an OS thread other than Racket&rsquo;s thread.</p><h5>3.1.3<tt>&nbsp;</tt><a name="(part._im~3a3m~3amzc)"></a>Local Pointers and <span class="stt">raco ctool</span> <span class="nobreak"><span class="stt">--xform</span></span></h5><p>When <span class="stt">raco ctool</span> is run with the <span class="nobreak"><span class="stt">--xform</span></span> flag and a source C program,
it produces a C program that is instrumented in the way described in
the previous section (but with a slightly different set of macros).
For each input file <span class="stt">"<span style="font-style: italic">name</span>.c"</span>, the transformed output
is <span class="stt">"<span style="font-style: italic">name</span>.3m.c"</span>.</p><p>The <span class="nobreak"><span class="stt">--xform</span></span> mode for <span class="stt">raco ctool</span> does not change allocation calls,
nor does it generate size, mark, or fixup procedures. It merely
converts the code to register local pointers.</p><p>Furthermore, the <span class="nobreak"><span class="stt">--xform</span></span> mode for <span class="stt">raco ctool</span> does not handle all of
C. It&rsquo;s ability to rearrange compound expressions is particularly
limited, because <span class="nobreak"><span class="stt">--xform</span></span> merely converts expression text
heuristically instead of parsing C. A future version of the tool will
correct such problems. For now, <span class="stt">raco ctool</span> in <span class="nobreak"><span class="stt">--xform</span></span> mode attempts
to provide reasonable error messages when it is unable to convert a
program, but beware that it can miss cases. To an even more limited
degree, <span class="nobreak"><span class="stt">--xform</span></span> can work on C++ code. Inspect the output of
<span class="nobreak"><span class="stt">--xform</span></span> mode to ensure that your code is correctly instrumented.</p><p>Some specific limitations:</p><ul><li><p>The body of a <span class="stt">for</span>, <span class="stt">while</span>, or <span class="stt">do</span> loop must be
surrounded with curly braces.  (A conversion error is normally
reported, otherwise.)</p></li><li><p>Function calls may not appear on the right-hand side of an
assignment within a declaration block.  (A conversion error is
normally reported if such an assignment is discovered.)</p></li><li><p>Multiple function calls in <span class="stt">... ? ... : ...</span> cannot be
lifted. (A conversion error is normally reported, otherwise.)</p></li><li><p>In an assignment, the left-hand side must be a local or static
variable, not a field selection, pointer dereference, etc. (A
conversion error is normally reported, otherwise.)</p></li><li><p>The conversion assumes that all function calls use an immediate
name for a function, as opposed to a compound expression as
in <span class="stt">s-&gt;f()</span>. The function name need not be a top-level
function name, but it must be bound either as an argument or
local variable with the form <span style="font-style: italic">type</span><span class="stt"> </span><span style="font-style: italic">id</span>; the
syntax <span style="font-style: italic">ret_type</span><span class="stt"> (*</span><span style="font-style: italic">id</span><span class="stt">)(...)</span> is not
recognized, so bind the function type to a simple name
with <span class="stt">typedef</span>, first: <span class="stt">typedef </span><span style="font-style: italic">ret_type</span><span class="stt">
</span><span class="stt">(*</span><span style="font-style: italic">type</span><span class="stt">)(...); .... </span><span style="font-style: italic">type</span><span class="stt"> </span><span style="font-style: italic">id</span>.</p></li><li><p>Arrays and structs must be passed by address, only.</p></li><li><p>GC-triggering code must not appear in system headers.</p></li><li><p>Pointer-comparison expressions are not handled correctly when
either of the compared expressions includes a function call.
For example, <span class="stt">a() == b()</span> is not converted correctly when
<span class="stt">a</span> and <span class="stt">b</span> produce pointer values.</p></li><li><p>Passing the address of a local pointer to a function works only
when the pointer variable remains live after the function call.</p></li><li><p>A <span class="stt">return;</span> form can get converted to <span class="stt">{ </span><span style="font-style: italic">stmt</span><span class="stt">; return; };</span>, which can break an <span class="stt">if (...) return; else
...</span> pattern.</p></li><li><p>Local instances of union types are generally not supported.</p></li><li><p>Pointer arithmetic cannot be converted away, and is instead
reported as an error.</p></li></ul><h5>3.1.4<tt>&nbsp;</tt><a name="(part._im~3a3m~3amacros)"></a>Guiding <span class="stt">raco ctool</span> <span class="nobreak"><span class="stt">--xform</span></span></h5><p>The following macros can be used (with care!) to navigate
<span class="nobreak"><span class="stt">--xform</span></span> around code that it cannot handle:</p><ul><li><p><a name="(cpp._.X.F.O.R.M_.S.T.A.R.T_.S.K.I.P)"></a><a name="(idx._(gentag._211._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.X.F.O.R.M_.S.T.A.R.T_.S.K.I.P)" class="RktStxLink" pltdoc="x"><span class="stt">XFORM_START_SKIP</span></a> and <a name="(cpp._.X.F.O.R.M_.E.N.D_.S.K.I.P)"></a><a name="(idx._(gentag._212._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.X.F.O.R.M_.E.N.D_.S.K.I.P)" class="RktStxLink" pltdoc="x"><span class="stt">XFORM_END_SKIP</span></a>: code
  between these two statements is ignored by the transform tool,
  except to tokenize it.</p><p>Example:</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int foo(int c, ...) {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int r = 0;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">XFORM_START_SKIP;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">/* va plays strange tricks that confuse xform */</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">va_list args;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">va_start(args, c);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">while (c--) {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">r += va_arg(args, int);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">XFORM_END_SKIP;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return r;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr></table></p><p>These macros can also be used at the top level, outside of any
 function.  Since they have to be terminated by a semi-colon, however,
 top-level uses usually must be wrapped with <span class="stt">#ifdef
MZ_PRECISE_GC</span> and <span class="stt">#endif</span>; a semi-colon by itself at the
 top level is not legal in C.</p></li><li><p><a name="(cpp._.X.F.O.R.M_.S.K.I.P_.P.R.O.C)"></a><a name="(idx._(gentag._213._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.X.F.O.R.M_.S.K.I.P_.P.R.O.C)" class="RktStxLink" pltdoc="x"><span class="stt">XFORM_SKIP_PROC</span></a>: annotate a function so that its body
    is skipped in the same way as bracketing it with
    <a href="#(cpp._.X.F.O.R.M_.S.T.A.R.T_.S.K.I.P)" class="RktStxLink" pltdoc="x"><span class="stt">XFORM_START_SKIP</span></a> and <a href="#(cpp._.X.F.O.R.M_.E.N.D_.S.K.I.P)" class="RktStxLink" pltdoc="x"><span class="stt">XFORM_END_SKIP</span></a>.</p><p>Example:</p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int foo(int c, ...) XFORM_END_SKIP {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr></table></li><li><p><a name="(cpp._.X.F.O.R.M_.H.I.D.E_.E.X.P.R)"></a><a name="(idx._(gentag._214._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.X.F.O.R.M_.H.I.D.E_.E.X.P.R)" class="RktStxLink" pltdoc="x"><span class="stt">XFORM_HIDE_EXPR</span></a>: a macro that takes wraps an expression to
disable processing of the expression.</p><p>Example:</p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int foo(int c, ...) {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int r = 0;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">/* va plays strange tricks that confuse xform */</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">XFORM_CAN_IGNORE va_list args; /* See below */</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">XFORM_HIDE_EXPR(va_start(args, c));</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">while (c--) {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">r += XFORM_HIDE_EXPR(va_arg(args, int));</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return r;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr></table></li><li><p><a name="(cpp._.X.F.O.R.M_.C.A.N_.I.G.N.O.R.E)"></a><a name="(idx._(gentag._215._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.X.F.O.R.M_.C.A.N_.I.G.N.O.R.E)" class="RktStxLink" pltdoc="x"><span class="stt">XFORM_CAN_IGNORE</span></a>: a macro that acts like a type
modifier (must appear first) to indicate that a declared variable
can be treated as atomic. See above for an example.</p></li><li><p><a name="(cpp._.X.F.O.R.M_.S.T.A.R.T_.S.U.S.P.E.N.D)"></a><a name="(idx._(gentag._216._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.X.F.O.R.M_.S.T.A.R.T_.S.U.S.P.E.N.D)" class="RktStxLink" pltdoc="x"><span class="stt">XFORM_START_SUSPEND</span></a> and <a name="(cpp._.X.F.O.R.M_.E.N.D_.S.U.S.P.E.N.D)"></a><a name="(idx._(gentag._217._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.X.F.O.R.M_.E.N.D_.S.U.S.P.E.N.D)" class="RktStxLink" pltdoc="x"><span class="stt">XFORM_END_SUSPEND</span></a>: for
use at the top level (outside of any function definition), and
similar to <a href="#(cpp._.X.F.O.R.M_.S.T.A.R.T_.S.K.I.P)" class="RktStxLink" pltdoc="x"><span class="stt">XFORM_START_SKIP</span></a> and <a href="#(cpp._.X.F.O.R.M_.E.N.D_.S.K.I.P)" class="RktStxLink" pltdoc="x"><span class="stt">XFORM_END_SKIP</span></a> in
that function and class bodies are not transformed. Type and
prototype information is still collected for use by later
transformations, however. These forms must be terminated by a
semi-colon.</p></li><li><p><a name="(cpp._.X.F.O.R.M_.S.T.A.R.T_.T.R.U.S.T_.A.R.I.T.H)"></a><a name="(idx._(gentag._218._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.X.F.O.R.M_.S.T.A.R.T_.T.R.U.S.T_.A.R.I.T.H)" class="RktStxLink" pltdoc="x"><span class="stt">XFORM_START_TRUST_ARITH</span></a> and
<a name="(cpp._.X.F.O.R.M_.E.N.D_.T.R.U.S.T_.A.R.I.T.H)"></a><a name="(idx._(gentag._219._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.X.F.O.R.M_.E.N.D_.T.R.U.S.T_.A.R.I.T.H)" class="RktStxLink" pltdoc="x"><span class="stt">XFORM_END_TRUST_ARITH</span></a>: for use at the top level (outside
of any function definition) to disable warnings about pointer
arithmetic. Use only when you&rsquo;re absolutely certain that the garbage
collector cannot be pointers offset into the middle of a collectable
object. These forms must be terminated by a semi-colon.</p></li><li><p><a name="(cpp._.X.F.O.R.M_.T.R.U.S.T_.P.L.U.S)"></a><a name="(idx._(gentag._220._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.X.F.O.R.M_.T.R.U.S.T_.P.L.U.S)" class="RktStxLink" pltdoc="x"><span class="stt">XFORM_TRUST_PLUS</span></a>: a replacement for <span class="stt">+</span> that does
not trigger pointer-arithmetic warnings. Use with care.</p></li><li><p><a name="(cpp._.X.F.O.R.M_.T.R.U.S.T_.M.I.N.U.S)"></a><a name="(idx._(gentag._221._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.X.F.O.R.M_.T.R.U.S.T_.M.I.N.U.S)" class="RktStxLink" pltdoc="x"><span class="stt">XFORM_TRUST_MINUS</span></a>: a replacement for <span class="stt">-</span> that does
not trigger pointer-arithmetic warnings. Use with care.</p></li></ul><h4>3.2<tt>&nbsp;</tt><a name="(part._.Memory_.Functions)"></a>Memory Functions</h4><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc)"></a><a name="(idx._(gentag._222._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_malloc)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-style: italic">n</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Allocates <span style="font-style: italic">n</span> bytes of collectable memory, initially filled with
zeros. In 3m, the allocated object is treated as an array of
pointers.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc_atomic)"></a><a name="(idx._(gentag._223._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_malloc_atomic)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_atomic</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-style: italic">n</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Allocates <span style="font-style: italic">n</span> bytes of collectable memory containing no pointers
visible to the garbage collector. The object is <span style="font-style: italic">not</span>
initialized to zeros.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc_uncollectable)"></a><a name="(idx._(gentag._224._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_malloc_uncollectable)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_uncollectable</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-style: italic">n</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Non-3m, only. Allocates <span style="font-style: italic">n</span> bytes of uncollectable memory.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc_eternal)"></a><a name="(idx._(gentag._225._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_malloc_eternal)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_eternal</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-style: italic">n</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Allocates uncollectable atomic memory. This function is equivalent to
 <span class="stt">malloc</span>, except that the memory cannot be freed.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_calloc)"></a><a name="(idx._(gentag._226._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_calloc)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_calloc</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-style: italic">num</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-style: italic">size</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Allocates <span style="font-style: italic">num</span> * <span style="font-style: italic">size</span> bytes of memory using <a href="#(cpp._scheme_malloc)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc</span></a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc_tagged)"></a><a name="(idx._(gentag._227._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_malloc_tagged)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_tagged</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-style: italic">n</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_malloc)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc</span></a>, but in 3m, the type tag determines how the
 garbage collector traverses the object; see <a href="" pltdoc="x">Memory Allocation</a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc_allow_interior)"></a><a name="(idx._(gentag._228._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_malloc_allow_interior)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_allow_interior</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-style: italic">n</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_malloc)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc</span></a>, but in 3m, pointers are allowed to
 reference the middle of the object; see <a href="" pltdoc="x">Memory Allocation</a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc_atomic_allow_interior)"></a><a name="(idx._(gentag._229._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_malloc_atomic_allow_interior)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_atomic_allow_interior</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-style: italic">n</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_malloc_atomic)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_atomic</span></a>, but in 3m, pointers are allowed to
 reference the middle of the object; see <a href="" pltdoc="x">Memory Allocation</a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">char*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_strdup)"></a><a name="(idx._(gentag._230._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_strdup)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_strdup</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">str</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Copies the null-terminated string <span style="font-style: italic">str</span>; the copy is collectable.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">char*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_strdup_eternal)"></a><a name="(idx._(gentag._231._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_strdup_eternal)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_strdup_eternal</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">str</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Copies the null-terminated string <span style="font-style: italic">str</span>; the copy will never be freed.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc_fail_ok)"></a><a name="(idx._(gentag._232._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_malloc_fail_ok)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_fail_ok</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-style: italic">size</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-style: italic">size</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Attempts to allocate <span style="font-style: italic">size</span> bytes using <span style="font-style: italic">mallocf</span>. If the
allocation fails, the <span class="RktSym">exn:misc:out-of-memory</span> exception is
raised.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void**</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc_immobile_box)"></a><a name="(idx._(gentag._233._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_malloc_immobile_box)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_immobile_box</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">p</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Allocates memory that is not garbage-collected and that does not move
(even with 3m), but whose first word contains a pointer to a
collectable object. The box is initialized with <span style="font-style: italic">p</span>, but the value
can be changed at any time. An immobile box must be explicitly freed
using <a href="#(cpp._scheme_free_immobile_box)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_free_immobile_box</span></a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_free_immobile_box)"></a><a name="(idx._(gentag._234._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_free_immobile_box)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_free_immobile_box</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void**</span><span class="hspace">&nbsp;</span><span style="font-style: italic">b</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Frees an immobile box allocated with <a href="#(cpp._scheme_malloc_immobile_box)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_immobile_box</span></a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc_code)"></a><a name="(idx._(gentag._235._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_malloc_code)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_code</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">size</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Allocates non-collectable memory to hold executable machine code. Use
this function instead of <span class="stt">malloc</span> to ensure that the allocated
memory has &ldquo;execute&rdquo; permissions. Use <a href="#(cpp._scheme_free_code)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_free_code</span></a> to free
memory allocated by this function.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_free_code)"></a><a name="(idx._(gentag._236._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_free_code)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_free_code</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">p</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Frees memory allocated with <a href="#(cpp._scheme_malloc_code)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_malloc_code</span></a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_register_extension_global)"></a><a name="(idx._(gentag._237._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_register_extension_global)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_register_extension_global</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">ptr</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">size</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Registers an extension&rsquo;s global variable that can contain Racket
 pointers. The address of the global is given in <span style="font-style: italic">ptr</span>, and its
 size in bytes in <span style="font-style: italic">size</span>.In addition to global variables, this
 function can be used to register any permanent memory that the
 collector would otherwise treat as atomic. A garbage collection can
 occur during the registration.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_main_setup)"></a><a name="(idx._(gentag._238._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_main_setup)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_main_setup</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">no_auto_statics</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Env_Main</span><span class="hspace">&nbsp;</span><span style="font-style: italic">main</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">argc</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">char**</span><span class="hspace">&nbsp;</span><span style="font-style: italic">argv</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Initializes the GC stack base, creates the initial namespace by
calling <a href="Evaluation.html#(cpp._scheme_basic_env)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_basic_env</span></a>, and then calls <span style="font-style: italic">main</span> with the
namespace, <span style="font-style: italic">argc</span>, and <span style="font-style: italic">argv</span>. (The <span style="font-style: italic">argc</span> and <span style="font-style: italic">argv</span>
are just passed on to <span style="font-style: italic">main</span>, and are not inspected in any way.)</div></p><p>The <span class="stt">Scheme_Env_Main</span> type is defined as follows:</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">typedef int (*Scheme_Env_Main)(Scheme_Env *env,</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">int argc, char **argv);</span></span></p></td></tr></table></p><p>The result of <span style="font-style: italic">main</span> is the result of <a href="#(cpp._scheme_main_setup)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_main_setup</span></a>.</p><p>If <span style="font-style: italic">no_auto_statics</span> is non-zero, then static variables must be
explicitly registered with the garbage collector; see
<a href="" pltdoc="x">Memory Allocation</a> for more information.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_main_stack_setup)"></a><a name="(idx._(gentag._239._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_main_stack_setup)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_main_stack_setup</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">no_auto_statics</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Nested_Main</span><span class="hspace">&nbsp;</span><span style="font-style: italic">main</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">data</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">A more primitive variant of <a href="#(cpp._scheme_main_setup)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_main_setup</span></a> that initializes
the GC stack base but does not create the initial namespace (so an
embedding application can perform other operations that involve
garbage-collected data before creating a namespace).</div></p><p>The <span style="font-style: italic">data</span> argument is passed through to <span style="font-style: italic">main</span>, where the
<span class="stt">Scheme_Nested_Main</span> type is defined as follows:</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">typedef int (*Scheme_Nested_Main)(void *data);</span></span></p></td></tr></table></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_set_stack_base)"></a><a name="(idx._(gentag._240._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_set_stack_base)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_set_stack_base</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">stack_addr</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">no_auto_statics</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Overrides the GC&rsquo;s auto-determined stack base, and/or disables the
 GC&rsquo;s automatic traversal of global and static variables. If
 <span style="font-style: italic">stack_addr</span> is <span class="stt">NULL</span>, the stack base determined by the GC is
 used. Otherwise, it should be the &ldquo;deepest&rdquo; memory address on the
 stack where a collectable pointer might be stored. This function
 should be called only once, and before any other <span class="stt">scheme_</span>
 function is called. It never triggers a garbage collection.</div></p><p>The following example shows a typical use for setting the stack base
for CGC:</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">int main(int argc, char **argv) {</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">int dummy;</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_set_stack_base(&amp;dummy, 0);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">real_main(argc, argv); /* calls scheme_basic_env(), etc. */</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">}</span></span></p></td></tr></table></p><p>Under 3m, the above code does not quite work, because <span style="font-style: italic">stack_addr</span>
must be the beginning or end of a local-frame registration. Worse, in
CGC or 3m, if <span class="stt">real_main</span> is declared <span class="stt">static</span>, the compiler
may inline it and place variables containing collectable values deeper
in the stack than <span class="stt">dummy</span>. To avoid these problems, use
<a href="#(cpp._scheme_main_setup)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_main_setup</span></a> or <a href="#(cpp._scheme_main_stack_setup)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_main_stack_setup</span></a>, instead.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_set_stack_bounds)"></a><a name="(idx._(gentag._241._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_set_stack_bounds)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_set_stack_bounds</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">stack_addr</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">stack_end</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">no_auto_statics</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_set_stack_base)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_set_stack_base</span></a>, except for the extra
<span style="font-style: italic">stack_end</span> argument. If <span style="font-style: italic">stack_end</span> is non-<span class="stt">NULL</span>, then
it corresponds to a point of C-stack growth after which Racket
should attempt to handle stack overflow. The <span style="font-style: italic">stack_end</span> argument
should not correspond to the actual stack end, since detecting stack
overflow may take a few frames, and since handling stack overflow
requires a few frames.</div></p><p>If <span style="font-style: italic">stack_end</span> is <span class="stt">NULL</span>, then the stack end is computed
automatically: the stack size assumed to be the limit reported by
<span class="stt">getrlimit</span> under Unix and Mac OS X, or it is assumed to be 1 MB
under Windows; if this size is greater than 8 MB, then 8 MB is
assumed, instead; the size is decremented by 50000 bytes to cover a
large margin of error; finally, the size is subtracted from (for
stacks that grow down) or added to (for stacks that grow up) the stack
base in <span style="font-style: italic">stack_addr</span> or the automatically computed stack
base. Note that the 50000-byte margin of error is assumed to cover the
difference between the actual stack start and the reported stack base,
in addition to the margin needed for detecting and handling stack
overflow.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_register_tls_space)"></a><a name="(idx._(gentag._242._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_register_tls_space)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_register_tls_space</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">ptr</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">tls_index</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Only available under Windows; registers <span style="font-style: italic">ptr</span> as the address of a
 thread-local pointer variable that is declared in the main
 executable. The variable&rsquo;s storage will be used to implement
 thread-local storage within the Racket run-time. See
 <a href="overview.html#(part._embedding)" pltdoc="x">Embedding Racket into a Program</a>.</div></p><p>The <span style="font-style: italic">tls_index</span> argument must be <span class="stt">0</span>. It is currently
 ignored, but a future version may use the argument to allow
 declaration of the thread-local variable in a dynamically linked
 DLL.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_register_static)"></a><a name="(idx._(gentag._243._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_register_static)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_register_static</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">ptr</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">size</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_register_extension_global)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_register_extension_global</span></a>, for use in embedding
 applications in situations where the collector does not automatically
 find static variables (i.e., when <a href="#(cpp._scheme_set_stack_base)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_set_stack_base</span></a> has
 been called with a non-zero second argument).</div></p><p>The macro <span class="stt">MZ_REGISTER_STATIC</span> can be used directly on a static
 variable. It expands to a comment if statics need not be registered,
 and a call to <a href="#(cpp._scheme_register_static)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_register_static</span></a> (with the address of the
 static variable) otherwise.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_weak_reference)"></a><a name="(idx._(gentag._244._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_weak_reference)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_weak_reference</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void**</span><span class="hspace">&nbsp;</span><span style="font-style: italic">p</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Registers the pointer <span style="font-style: italic">*p</span> as a weak pointer; when no other
(non-weak) pointers reference the same memory as <span style="font-style: italic">*p</span> references,
then <span style="font-style: italic">*p</span> will be set to <span class="stt">NULL</span> by the garbage collector. The
value in <span style="font-style: italic">*p</span> may change, but the pointer remains weak with
respect to the value of <span style="font-style: italic">*p</span> at the time <span style="font-style: italic">p</span> was registered.</div></p><p>This function is not available in 3m.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_weak_reference_indirect)"></a><a name="(idx._(gentag._245._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_weak_reference_indirect)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_weak_reference_indirect</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void**</span><span class="hspace">&nbsp;</span><span style="font-style: italic">p</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">v</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_weak_reference)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_weak_reference</span></a>, but <span style="font-style: italic">*p</span> is set to <span class="stt">NULL</span>
(regardless of its prior value) when there are no references to <span style="font-style: italic">v</span>.</div></p><p>This function is not available in 3m.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_register_finalizer)"></a><a name="(idx._(gentag._246._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_register_finalizer)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_register_finalizer</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">p</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">fnl_proc</span><span class="hspace">&nbsp;</span><span style="font-style: italic">f</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">data</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">fnl_proc*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">oldf</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void**</span><span class="hspace">&nbsp;</span><span style="font-style: italic">olddata</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Registers a callback function to be invoked when the memory <span style="font-style: italic">p</span>
would otherwise be garbage-collected, and when no &ldquo;will&rdquo;-like
finalizers are registered for <span style="font-style: italic">p</span>.</div></p><p>The <span class="stt">fnl_proc</span> type is not actually defined, but it is equivalent
to</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">typedef void (*fnl_proc)(void *p, void *data)</span></span></p></td></tr></table></p><p>The <span style="font-style: italic">f</span> argument is the callback function; when it is called, it
will be passed the value <span style="font-style: italic">p</span> and the data pointer <span style="font-style: italic">data</span>;
<span style="font-style: italic">data</span> can be anything  &ndash;  it is only passed on to the callback
function. If <span style="font-style: italic">oldf</span> and <span style="font-style: italic">olddata</span> are not <span class="stt">NULL</span>, then
<span style="font-style: italic">*oldf</span> and <span style="font-style: italic">*olddata</span> are filled with the old callback
information (<span style="font-style: italic">f</span> and <span style="font-style: italic">data</span> will override this old callback).</p><p>To remove a registered finalizer, pass <span class="stt">NULL</span> for <span style="font-style: italic">f</span> and
<span style="font-style: italic">data</span>.</p><p>Note: registering a callback not only keeps <span style="font-style: italic">p</span> from collection
until the callback is invoked, but it also keeps <span style="font-style: italic">data</span> reachable
until the callback is invoked.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_add_finalizer)"></a><a name="(idx._(gentag._247._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_add_finalizer)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_add_finalizer</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">p</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">fnl_proc</span><span class="hspace">&nbsp;</span><span style="font-style: italic">f</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">data</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Adds a finalizer to a chain of primitive finalizers. This chain is
separate from the single finalizer installed with
<a href="#(cpp._scheme_register_finalizer)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_register_finalizer</span></a>; all finalizers in the chain are
called immediately after a finalizer that is installed with
<a href="#(cpp._scheme_register_finalizer)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_register_finalizer</span></a>.</div></p><p>See <a href="#(cpp._scheme_register_finalizer)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_register_finalizer</span></a>, above, for information about
the arguments.</p><p>To remove an added finalizer, use <a href="#(cpp._scheme_subtract_finalizer)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_subtract_finalizer</span></a>.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_add_scheme_finalizer)"></a><a name="(idx._(gentag._248._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_add_scheme_finalizer)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_add_scheme_finalizer</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">p</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">fnl_proc</span><span class="hspace">&nbsp;</span><span style="font-style: italic">f</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">data</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Installs a &ldquo;will&rdquo;-like finalizer, similar to <span class="RktSym"><a href="../reference/willexecutor.html#(def._((quote._~23~25kernel)._will-register))" class="RktValLink" pltdoc="x">will-register</a></span>.
 Scheme finalizers are called one at a time, requiring the collector
 to prove that a value has become inaccessible again before calling
 the next Racket finalizer. Finalizers registered with
 <a href="#(cpp._scheme_register_finalizer)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_register_finalizer</span></a> or <a href="#(cpp._scheme_add_finalizer)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_add_finalizer</span></a> are
 not called until all Racket finalizers have been exhausted.</div></p><p>See <a href="#(cpp._scheme_register_finalizer)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_register_finalizer</span></a>, above, for information about
 the arguments.</p><p>There is currently no facility to remove a &ldquo;will&rdquo;-like finalizer.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_add_finalizer_once)"></a><a name="(idx._(gentag._249._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_add_finalizer_once)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_add_finalizer_once</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">p</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">fnl_proc</span><span class="hspace">&nbsp;</span><span style="font-style: italic">f</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">data</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_add_finalizer)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_add_finalizer</span></a>, but if the combination <span style="font-style: italic">f</span> and
 <span style="font-style: italic">data</span> is already registered as a (non-&ldquo;will&rdquo;-like) finalizer
 for <span style="font-style: italic">p</span>, it is not added a second time.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_add_scheme_finalizer_once)"></a><a name="(idx._(gentag._250._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_add_scheme_finalizer_once)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_add_scheme_finalizer_once</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">p</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">fnl_proc</span><span class="hspace">&nbsp;</span><span style="font-style: italic">f</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">data</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_add_scheme_finalizer)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_add_scheme_finalizer</span></a>, but if the combination of
 <span style="font-style: italic">f</span> and <span style="font-style: italic">data</span> is already registered as a &ldquo;will&rdquo;-like
 finalizer for <span style="font-style: italic">p</span>, it is not added a second time.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_subtract_finalizer)"></a><a name="(idx._(gentag._251._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_subtract_finalizer)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_subtract_finalizer</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">p</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">fnl_proc</span><span class="hspace">&nbsp;</span><span style="font-style: italic">f</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">data</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Removes a finalizer that was installed with
 <a href="#(cpp._scheme_add_finalizer)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_add_finalizer</span></a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_remove_all_finalization)"></a><a name="(idx._(gentag._252._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_remove_all_finalization)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_remove_all_finalization</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">p</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Removes all finalization (&ldquo;will&rdquo;-like or not) for <span style="font-style: italic">p</span>, including
 wills added in Scheme with <span class="RktSym"><a href="../reference/willexecutor.html#(def._((quote._~23~25kernel)._will-register))" class="RktValLink" pltdoc="x">will-register</a></span> and finalizers used
 by custodians.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_dont_gc_ptr)"></a><a name="(idx._(gentag._253._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_dont_gc_ptr)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_dont_gc_ptr</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">p</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Keeps the collectable block <span style="font-style: italic">p</span> from garbage collection. Use this
 procedure when a reference to <span style="font-style: italic">p</span> is be stored somewhere
 inaccessible to the collector. Once the reference is no longer used
 from the inaccessible region, de-register the lock with
 <a href="#(cpp._scheme_gc_ptr_ok)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_gc_ptr_ok</span></a>. A garbage collection can occur during the
 registration.</div></p><p>This function keeps a reference count on the pointers it registers, so
 two calls to <a href="#(cpp._scheme_dont_gc_ptr)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_dont_gc_ptr</span></a> for the same <span style="font-style: italic">p</span> should
 be balanced with two calls to <a href="#(cpp._scheme_gc_ptr_ok)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_gc_ptr_ok</span></a>.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_gc_ptr_ok)"></a><a name="(idx._(gentag._254._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_gc_ptr_ok)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_gc_ptr_ok</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">p</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">See <a href="#(cpp._scheme_dont_gc_ptr)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_dont_gc_ptr</span></a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_collect_garbage)"></a><a name="(idx._(gentag._255._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_collect_garbage)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_collect_garbage</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Forces an immediate garbage-collection.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._.G.C_register_traversers)"></a><a name="(idx._(gentag._256._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.G.C_register_traversers)" class="RktStxLink" pltdoc="x"><span class="stt">GC_register_traversers</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">short</span><span class="hspace">&nbsp;</span><span style="font-style: italic">tag</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Size_Proc</span><span class="hspace">&nbsp;</span><span style="font-style: italic">s</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Mark_Proc</span><span class="hspace">&nbsp;</span><span style="font-style: italic">m</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Fixup_Proc</span><span class="hspace">&nbsp;</span><span style="font-style: italic">f</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">is_const_size</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">is_atomic</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">3m only. Registers a size, mark, and fixup procedure for a given type
 tag; see <a href="#(part._im~3a3m~3atagged)" pltdoc="x">Tagged Objects</a> for more information.</div></p><p>Each of the three procedures takes a pointer and returns an integer:</p><p><table cellspacing="0"><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">typedef int (*Size_Proc)(void *obj);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">typedef int (*Mark_Proc)(void *obj);</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">typedef int (*Fixup_Proc)(void *obj);</span></span></p></td></tr></table></p><p>If the result of the size procedure is a constant, then pass a
 non-zero value for <span style="font-style: italic">is_const_size</span>. If the mark and fixup
 procedures are no-ops, then pass a non-zero value
 for <span style="font-style: italic">is_atomic</span>.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._.G.C_resolve)"></a><a name="(idx._(gentag._257._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.G.C_resolve)" class="RktStxLink" pltdoc="x"><span class="stt">GC_resolve</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">p</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">3m only. Can be called by a size, mark, or fixup procedure that is registered
with <a href="#(cpp._.G.C_register_traversers)" class="RktStxLink" pltdoc="x"><span class="stt">GC_register_traversers</span></a>. It returns the current address of
an object <span style="font-style: italic">p</span> that might have been moved already, where <span style="font-style: italic">p</span>
corresponds to an object that is referenced directly by the object
being sized, marked, or fixed. This translation is necessary, for
example, if the size or structure of an object depends on the content
of an object it references. For example, the size of a class instance
usually depends on a field count that is stored in the class. A fixup
procedure should call this function on a reference <span style="font-style: italic">before</span>
fixing it.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._.G.C_fixup_self)"></a><a name="(idx._(gentag._258._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._.G.C_fixup_self)" class="RktStxLink" pltdoc="x"><span class="stt">GC_fixup_self</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">p</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">3m only. Can be called by a fixup procedure that is registered with
<a href="#(cpp._.G.C_register_traversers)" class="RktStxLink" pltdoc="x"><span class="stt">GC_register_traversers</span></a>. It returns the final address of <span style="font-style: italic">p</span>,
which must be the pointer passed to the fixup procedure. For some
implementations of the memory manager, the result is the same as
<span style="font-style: italic">p</span>, either because objects are not moved or because the object is
moved before it is fixed. With other implementations, an object might
be moved after the fixup process, and the result is the location that
the object will have after garbage collection finished.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">Scheme_Object*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_add_gc_callback)"></a><a name="(idx._(gentag._259._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_add_gc_callback)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_add_gc_callback</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">pre_desc</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">post_desc</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Registers descriptions of foreign functions to be called just before
and just after a garbage collection. The foreign functions must not
allocate garbage-collected memory, and they are called in a way that
does not allocate, which is why <span style="font-style: italic">pre_desc</span> and <span style="font-style: italic">post_desc</span> are
function descriptions instead of thunks.</div></p><p>A description is a vector of vectors, where each of the inner vectors
describes a single call, and the calls are performed in sequence. Each
call vector starts with a symbol that indicates the protocol of the
foreign function to be called. The following protocols are supported:</p><ul><li><p><span class="RktVal">'</span><span class="RktVal">ptr_ptr_ptr-&gt;void</span> corresponds to <span class="stt">void
(*)(void*, void*, void*)</span>.</p></li><li><p><span class="RktVal">'</span><span class="RktVal">ptr_ptr_ptr_int-&gt;void</span> corresponds to <span class="stt">void
(*)(void*, void*, void*, int)</span>.</p></li><li><p><span class="RktVal">'</span><span class="RktVal">ptr_ptr_float-&gt;void</span> corresponds to <span class="stt">void
(*)(void*, void*, float)</span>.</p></li><li><p><span class="RktVal">'</span><span class="RktVal">ptr_ptr_double-&gt;void</span> corresponds to <span class="stt">void
(*)(void*, void*, double)</span>.</p></li><li><p><span class="RktVal">'</span><span class="RktVal">ptr_ptr_ptr_int_int_int_int_int_int_int_int_int-&gt;void</span>
corresponds to <span class="stt">void (*)(void*, void*, void*, int, int, int, int,
int, int, int, int, int)</span>.</p></li><li><p><span class="RktVal">'</span><span class="RktVal">osapi_ptr_int-&gt;void</span> corresponds to <span class="stt">void
(*)(void*, int)</span>, but using the stdcall calling convention
under Windows.</p></li><li><p><span class="RktVal">'</span><span class="RktVal">osapi_ptr_ptr-&gt;void</span> corresponds to <span class="stt">void
(*)(void*, void*)</span>, but using the stdcall calling convention
under Windows.</p></li><li><p><span class="RktVal">'</span><span class="RktVal">osapi_ptr_int_int_int_int_ptr_int_int_long-&gt;void</span>
corresponds to <span class="stt">void (*)(void*, int, int, int, int, void*,
int, int, long)</span>, but using the stdcall calling convention
under Windows.</p></li></ul><p>After the protocol symbol, the vector should contain a pointer to a
foreign function and then an element for each of the function&rsquo;s
arguments. Pointer values are represented as for the <span class="RktSym"><a href="../foreign/Pointer_Types.html#(def._((quote._~23~25foreign).__pointer))" class="RktValLink" pltdoc="x">_pointer</a></span>
representation defined by <a href="../foreign/index.html" class="RktModLink" pltdoc="x"><span class="RktSym">ffi/unsafe</span></a>.</p><p>The result is a key for use with <a href="#(cpp._scheme_remove_gc_callback)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_remove_gc_callback</span></a>. If
the key becomes inaccessible, then the callback will be removed
automatically (but beware that the pre-callback will have executed and
the post-callback will not have executed).</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_remove_gc_callback)"></a><a name="(idx._(gentag._260._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_remove_gc_callback)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_remove_gc_callback</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">key</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Removes a garbage-collection callback installed with <a href="#(cpp._scheme_add_gc_callback)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_add_gc_callback</span></a>.</div></p><div class="navsetbottom"><span class="navleft"><form class="searchform"><input class="searchbox" style="color: #888;" type="text" value="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;5.0.2&quot;, &quot;../&quot;);" onfocus="this.style.color=&quot;black&quot;; this.style.textAlign=&quot;left&quot;; if (this.value == &quot;...search manuals...&quot;) this.value=&quot;&quot;;" onblur="if (this.value.match(/^ *$/)) { this.style.color=&quot;#888&quot;; this.style.textAlign=&quot;center&quot;; this.value=&quot;...search manuals...&quot;; }" /></form>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" pltdoc="x" onclick="return GotoPLTRoot(&quot;5.0.2&quot;);">top</a></span><span class="navright"><a href="im_values_types.html" title="backward to &quot;2 Values and Types&quot;" pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Inside: Racket C API&quot;" pltdoc="x">up</a>&nbsp;&nbsp;<a href="im_env.html" title="forward to &quot;4 Namespaces and Modules&quot;" pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>