<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text-html; charset=utf-8" /><title>2&nbsp;Parsers</title><link rel="stylesheet" type="text/css" href="../scribble.css" title="default" /><link rel="stylesheet" type="text/css" href="../racket.css" title="default" /><link rel="stylesheet" type="text/css" href="../scribble-style.css" title="default" /><script type="text/javascript" src="../scribble-common.js"></script></head><body id="doc-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist" style="margin-bottom: 1em;"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" pltdoc="x"><span style="font-weight: bold">Parser Tools</span>:<span class="mywbr"> </span> <span class="stt">lex</span> and <span class="stt">yacc</span>-<wbr></wbr>style Parsing</a></td></tr></table></div><div class="tocviewsublistonly" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Lexers.html" class="tocviewlink" pltdoc="x">Lexers</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="" class="tocviewselflink" pltdoc="x">Parsers</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="Converting_yacc_or_bison_Grammars.html" class="tocviewlink" pltdoc="x">Converting <span class="stt">yacc</span> or <span class="stt">bison</span> Grammars</a></td></tr><tr><td align="right"></td><td><a href="doc-index.html" class="tocviewlink" pltdoc="x">Index</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><a href="#(form._((lib._parser-tools/yacc..rkt)._parser))" class="tocsublink" pltdoc="x"><span title="Provided from: parser-tools/yacc"><span class="RktSym"><span class="RktStxLink">parser</span></span></span></a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><form class="searchform"><input class="searchbox" style="color: #888;" type="text" value="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;5.0.2&quot;, &quot;../&quot;);" onfocus="this.style.color=&quot;black&quot;; this.style.textAlign=&quot;left&quot;; if (this.value == &quot;...search manuals...&quot;) this.value=&quot;&quot;;" onblur="if (this.value.match(/^ *$/)) { this.style.color=&quot;#888&quot;; this.style.textAlign=&quot;center&quot;; this.value=&quot;...search manuals...&quot;; }" /></form>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" pltdoc="x" onclick="return GotoPLTRoot(&quot;5.0.2&quot;);">top</a></span><span class="navright"><a href="Lexers.html" title="backward to &quot;1 Lexers&quot;" pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Parser Tools: lex and yacc-style Parsing&quot;" pltdoc="x">up</a>&nbsp;&nbsp;<a href="Converting_yacc_or_bison_Grammars.html" title="forward to &quot;3 Converting yacc or bison Grammars&quot;" pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>2<tt>&nbsp;</tt><a name="(part._.Parsers)"></a><a name="(mod-path._parser-tools/yacc)"></a>Parsers</h3><p><table cellspacing="0" class="defmodule"><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/require.html#(form._((lib._racket/private/base..rkt)._require))" class="RktStxLink" pltdoc="x">require</a></span><span class="stt"> </span><a href="" class="RktModLink" pltdoc="x"><span class="RktSym">parser-tools/yacc</span></a><span class="RktPn">)</span></td></tr></table></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/yacc..rkt)._parser))"></a><a name="(form._((lib._parser-tools/yacc..rkt)._parser))"></a><span title="Provided from: parser-tools/yacc"><span class="RktSym"><a href="#(form._((lib._parser-tools/yacc..rkt)._parser))" class="RktStxLink" pltdoc="x">parser</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">clause</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr><tr><td><span class="stt">&nbsp;</span></td></tr><tr><td><table cellspacing="0" class="specgrammar"><tr><td align="right" valign="baseline"><span class="RktVar">clause</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">=</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">grammar</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">non-terminal-id</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktVar">grammar-id</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVar">maybe-prec</span><span class="hspace">&nbsp;</span><span class="RktVar">expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">tokens</span><span class="hspace">&nbsp;</span><span class="RktVar">group-id</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">start</span><span class="hspace">&nbsp;</span><span class="RktVar">non-terminal-id</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">end</span><span class="hspace">&nbsp;</span><span class="RktVar">token-id</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVar">expr</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">precs</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">assoc</span><span class="hspace">&nbsp;</span><span class="RktVar">token-id</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">src-pos</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">suppress</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">debug</span><span class="hspace">&nbsp;</span><span class="RktVar">filename</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">yacc-output</span><span class="hspace">&nbsp;</span><span class="RktVar">filename</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td></tr><tr><td align="right" valign="baseline"><span class="RktVar">maybe-prec</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">=</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><table cellspacing="0" class="RktBlk"><tr><td></td></tr></table></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">prec</span><span class="hspace">&nbsp;</span><span class="RktVar">token-id</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td></tr><tr><td align="right" valign="baseline"><span class="RktVar">assoc</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">=</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktVar">left</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktVar">right</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktVar">nonassoc</span></td></tr></table></td></tr></table></div><div class="SIntrapara">Creates a parser. The clauses may be in any order, as long as there
are no duplicates and all non-<span style="font-style: italic">OPTIONAL</span> declarations are
present:</div></p><ul><li><p><table cellspacing="0" style="display: inline-table; vertical-align: text-top;" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">grammar</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">non-terminal-id</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktVar">grammar-id</span><span class="hspace">&nbsp;</span><span class="RktMeta"><a href="../reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" class="RktStxLink" pltdoc="x">...</a></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVar">maybe-prec</span><span class="hspace">&nbsp;</span><span class="RktVar">expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"><a href="../reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" class="RktStxLink" pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"><a href="../reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" class="RktStxLink" pltdoc="x">...</a></span><span class="RktPn">)</span></td></tr></table></p><p>Declares the grammar to be parsed.  Each <span class="RktVar">grammar-id</span> can
be a <span class="RktVar">token-id</span> from a <span class="RktVar">group-id</span> named in a
<span class="RktSym">tokens</span> declaration, or it can be a
<span class="RktVar">non-terminal-id</span> declared in the <span class="RktSym">grammar</span>
declaration. The optional <span class="RktSym">prec</span> declaration works with
the <span class="RktSym">precs</span> declaration. The <span class="RktVar">expr</span> is a
&ldquo;semantic action,&rdquo; which is evaluated when the input is found
to match its corresponding production.</p><p>Each action is scheme code that has the same scope as its
parser&rsquo;s definition, except that the variables <span class="RktSym">$1</span>, ...,
<span class="RktSym">$</span><span style="font-style: italic">i</span> are bound, where <span style="font-style: italic">i</span> is the number
of <span class="RktVar">grammar-id</span>s in the corresponding production. Each
<span class="RktSym">$</span><span style="font-style: italic">k</span> is bound to the result of the action
for the <span style="font-style: italic">k</span><span style="vertical-align: super; font-size: 80%">th</span> grammar symbol on the right of
the production, if that grammar symbol is a non-terminal, or the
value stored in the token if the grammar symbol is a terminal.
If the <span class="RktSym">src-pos</span> option is present in the parser, then
variables <span class="RktSym">$1-start-pos</span>, ...,
<span class="RktSym">$</span><span style="font-style: italic">i</span><span class="RktSym">-start-pos</span> and
<span class="RktSym">$1-end-pos</span>, ...,
<span class="RktSym">$</span><span style="font-style: italic">i</span><span class="RktSym">-end-pos</span> and are also
available, and they refer to the position structures
corresponding to the start and end of the corresponding
<span class="RktSym">grammar-symbol</span>. Grammar symbols defined as empty-tokens
have no <span class="RktSym">$</span><span style="font-style: italic">k</span> associated, but do have
<span class="RktSym">$</span><span style="font-style: italic">k</span><span class="RktSym">-start-pos</span> and
<span class="RktSym">$</span><span style="font-style: italic">k</span><span class="RktSym">-end-pos</span>.
Also <span class="RktSym">$n-start-pos</span> and <span class="RktSym">$n-end-pos</span>
are bound to the largest start and end positions, (i.e.,
<span class="RktSym">$</span><span style="font-style: italic">i</span><span class="RktSym">-start-pos</span> and
<span class="RktSym">$</span><span style="font-style: italic">i</span><span class="RktSym">-end-pos</span>).</p><p>All of the productions for a given non-terminal must be grouped
with it. That is, no <span class="RktVar">non-terminal-id</span> may appear twice
on the left hand side in a parser.</p></li><li><p><span class="RktPn">(</span><span class="RktSym">tokens</span><span class="stt"> </span><span class="RktVar">group-id</span><span class="stt"> </span><span class="RktMeta"><a href="../reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" class="RktStxLink" pltdoc="x">...</a></span><span class="RktPn">)</span></p><p>Declares that all of the tokens defined in each
<span class="RktVar">group-id</span> &ndash; as bound by <span class="RktSym"><a href="Lexers.html#(form._((lib._parser-tools/lex..rkt)._define-tokens))" class="RktStxLink" pltdoc="x">define-tokens</a></span> or
<span class="RktSym"><a href="Lexers.html#(form._((lib._parser-tools/lex..rkt)._define-empty-tokens))" class="RktStxLink" pltdoc="x">define-empty-tokens</a></span> &ndash; can be used by the parser in the
<span class="RktSym">grammar</span> declaration.</p></li><li><p><span class="RktPn">(</span><span class="RktSym">start</span><span class="stt"> </span><span class="RktVar">non-terminal-id</span><span class="stt"> </span><span class="RktMeta"><a href="../reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" class="RktStxLink" pltdoc="x">...</a></span><span class="RktPn">)</span></p><p>Declares a list of starting non-terminals for the grammar.</p></li><li><p><span class="RktPn">(</span><span class="RktSym">end</span><span class="stt"> </span><span class="RktVar">token-id</span><span class="stt"> </span><span class="RktMeta"><a href="../reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" class="RktStxLink" pltdoc="x">...</a></span><span class="RktPn">)</span></p><p>Specifies a set of tokens from which some member must follow any
valid parse.  For example, an EOF token would be specified for a
parser that parses entire files and a newline token for a parser
that parses entire lines individually.</p></li><li><p><span class="RktPn">(</span><span class="RktSym">error</span><span class="stt"> </span><span class="RktVar">expr</span><span class="RktPn">)</span></p><p>The <span class="RktVar">expr</span> should evaluate to a function which will be
executed for its side-effect whenever the parser encounters an
error.</p><p>If the <span class="RktSym">src-pos</span> declaration is present, the function
should accept 5 arguments,:</p><p><table cellspacing="0" class="RktBlk"><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/lambda.html#(form._((lib._racket/private/base..rkt)._lambda))" class="RktStxLink" pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tok-ok?</span><span class="hspace">&nbsp;</span><span class="RktSym">tok-name</span><span class="hspace">&nbsp;</span><span class="RktSym">tok-value</span><span class="hspace">&nbsp;</span><span class="RktVar">start-pos</span><span class="hspace">&nbsp;</span><span class="RktVar">end-pos</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">....</span><span class="RktPn">)</span></td></tr></table></p><p>Otherwise it should accept 3:</p><p><table cellspacing="0" class="RktBlk"><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/lambda.html#(form._((lib._racket/private/base..rkt)._lambda))" class="RktStxLink" pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tok-ok?</span><span class="hspace">&nbsp;</span><span class="RktSym">tok-name</span><span class="hspace">&nbsp;</span><span class="RktSym">tok-value</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">....</span><span class="RktPn">)</span></td></tr></table></p><p>The first argument will be <span class="RktVal">#f</span> if and only if the error
is that an invalid token was received.  The second and third
arguments will be the name and the value of the token at which
the error was detected.  The fourth and fifth arguments, if
present, provide the source positions of that token.</p></li><li><p><span class="RktPn">(</span><span class="RktSym">precs</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktVar">assoc</span><span class="stt"> </span><span class="RktVar">token-id</span><span class="stt"> </span><span class="RktMeta"><a href="../reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" class="RktStxLink" pltdoc="x">...</a></span><span class="RktPn">)</span><span class="stt"> </span><span class="RktMeta"><a href="../reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" class="RktStxLink" pltdoc="x">...</a></span><span class="RktPn">)</span>
<span style="font-style: italic">OPTIONAL</span></p><p>Precedence declarations to resolve shift/reduce and
reduce/reduce conflicts as in <span class="stt">yacc</span>/<span class="stt">bison</span>. An
<span class="RktVar">assoc</span> must be one of <span class="RktVar">left</span>, <span class="RktVar">right</span> or
<span class="RktVar">nonassoc</span>.  States with multiple shift/reduce or
reduce/reduce conflicts (or some combination thereof) are not
resolved with precedence.</p></li><li><p><span class="RktPn">(</span><span class="RktSym">src-pos</span><span class="RktPn">)</span> <span style="font-style: italic">OPTIONAL</span></p><p>Causes the generated parser to expect input in the form
<span class="RktPn">(</span><span class="RktSym"><a href="Lexers.html#(def._((lib._parser-tools/lex..rkt)._make-position-token))" class="RktValLink" pltdoc="x">make-position-token</a></span><span class="stt"> </span><span class="RktVar">token</span><span class="stt"> </span><span class="RktVar">start-pos</span><span class="stt"> </span><span class="RktVar">end-pos</span><span class="RktPn">)</span> instead
of simply <span class="RktVar">token</span>.  Include this option when using the
parser with a lexer generated with <span class="RktSym"><a href="Lexers.html#(form._((lib._parser-tools/lex..rkt)._lexer-src-pos))" class="RktStxLink" pltdoc="x">lexer-src-pos</a></span>.</p></li><li><p><span class="RktPn">(</span><span class="RktSym">debug</span><span class="stt"> </span><span class="RktVar">filename</span><span class="RktPn">)</span> <span style="font-style: italic">OPTIONAL</span></p><p>Causes the parser generator to write the LALR table to the file
named <span class="RktVar">filename</span> (unless the file exists), where
<span class="RktVar">filename</span> is a literal string.  Additionally, if a debug
file is specified, when a running generated parser encounters a
parse error on some input file, after the user specified error
expression returns, the complete parse stack is printed to
assist in debugging the grammar of that particular parser.  The
numbers in the stack printout correspond to the state numbers in
the LALR table file.</p></li><li><p><span class="RktPn">(</span><span class="RktSym">yacc-output</span><span class="stt"> </span><span class="RktVar">filename</span><span class="RktPn">)</span> <span style="font-style: italic">OPTIONAL</span></p><p>Causes the parser generator to write a grammar file in
approximately the syntax of <span class="stt">yacc</span>/<span class="stt">bison</span>.  The file
might not be a valid <span class="stt">yacc</span> file, because the scheme
grammar can use symbols that are invalid in C.</p></li><li><p><span class="RktPn">(</span><span class="RktSym">suppress</span><span class="RktPn">)</span> <span style="font-style: italic">OPTIONAL</span></p><p>Causes the parser generator not to report shift/reduce or
reduce/reduce conflicts.</p></li></ul><p>The result of a <span class="RktSym"><a href="#(form._((lib._parser-tools/yacc..rkt)._parser))" class="RktStxLink" pltdoc="x">parser</a></span> expression with one <span class="RktSym">start</span>
non-terminal is a function, <span class="RktVar">parse</span>, that takes one
argument.  This argument must be a zero argument function,
<span class="RktVar">gen</span>, that produces successive tokens of the input each
time it is called.  If desired, the <span class="RktVar">gen</span> may return
symbols instead of tokens, and the parser will treat symbols as
tokens of the corresponding name (with <span class="RktVal">#f</span> as a value, so
it is usual to return symbols only in the case of empty tokens).
The <span class="RktVar">parse</span> function returns the value associated with the
parse tree by the semantic actions.  If the parser encounters an
error, after invoking the supplied error function, it will try to
use error productions to continue parsing.  If it cannot, it
raises <span class="RktSym"><a href="../reference/exns.html#(def._((lib._racket/private/base..rkt)._exn~3afail~3aread))" class="RktValLink" pltdoc="x">exn:fail:read</a></span>.</p><p>If multiple non-terminals are provided in <span class="RktSym">start</span>, the
<span class="RktSym"><a href="#(form._((lib._parser-tools/yacc..rkt)._parser))" class="RktStxLink" pltdoc="x">parser</a></span> expression produces a list of parsing functions,
one for each non-terminal in the same order. Each parsing function
is like the result of a parser expression with only one
<span class="RktSym">start</span> non-terminal,</p><p>Each time the scheme code for a <span class="RktSym"><a href="#(form._((lib._parser-tools/yacc..rkt)._parser))" class="RktStxLink" pltdoc="x">parser</a></span> is compiled
(e.g. when a <span class="stt">".ss"</span> file containing a <span class="RktSym"><a href="#(form._((lib._parser-tools/yacc..rkt)._parser))" class="RktStxLink" pltdoc="x">parser</a></span> form
is loaded), the parser generator is run.  To avoid this overhead
place the parser into a module and compile the module to a
<span class="stt">".zo"</span> bytecode file.</p><div class="navsetbottom"><span class="navleft"><form class="searchform"><input class="searchbox" style="color: #888;" type="text" value="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;5.0.2&quot;, &quot;../&quot;);" onfocus="this.style.color=&quot;black&quot;; this.style.textAlign=&quot;left&quot;; if (this.value == &quot;...search manuals...&quot;) this.value=&quot;&quot;;" onblur="if (this.value.match(/^ *$/)) { this.style.color=&quot;#888&quot;; this.style.textAlign=&quot;center&quot;; this.value=&quot;...search manuals...&quot;; }" /></form>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" pltdoc="x" onclick="return GotoPLTRoot(&quot;5.0.2&quot;);">top</a></span><span class="navright"><a href="Lexers.html" title="backward to &quot;1 Lexers&quot;" pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Parser Tools: lex and yacc-style Parsing&quot;" pltdoc="x">up</a>&nbsp;&nbsp;<a href="Converting_yacc_or_bison_Grammars.html" title="forward to &quot;3 Converting yacc or bison Grammars&quot;" pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>