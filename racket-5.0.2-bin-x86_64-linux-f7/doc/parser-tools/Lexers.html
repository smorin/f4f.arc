<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text-html; charset=utf-8" /><title>1&nbsp;Lexers</title><link rel="stylesheet" type="text/css" href="../scribble.css" title="default" /><link rel="stylesheet" type="text/css" href="../racket.css" title="default" /><link rel="stylesheet" type="text/css" href="../scribble-style.css" title="default" /><script type="text/javascript" src="../scribble-common.js"></script></head><body id="doc-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist" style="margin-bottom: 1em;"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" pltdoc="x"><span style="font-weight: bold">Parser Tools</span>:<span class="mywbr"> </span> <span class="stt">lex</span> and <span class="stt">yacc</span>-<wbr></wbr>style Parsing</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="" class="tocviewselflink" pltdoc="x">Lexers</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Parsers.html" class="tocviewlink" pltdoc="x">Parsers</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="Converting_yacc_or_bison_Grammars.html" class="tocviewlink" pltdoc="x">Converting <span class="stt">yacc</span> or <span class="stt">bison</span> Grammars</a></td></tr><tr><td align="right"></td><td><a href="doc-index.html" class="tocviewlink" pltdoc="x">Index</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>1&nbsp;</td><td><a href="" class="tocviewselflink" pltdoc="x">Lexers</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">1.1&nbsp;</td><td><a href="#(part._.Creating_a_.Lexer)" class="tocviewlink" pltdoc="x">Creating a Lexer</a></td></tr><tr><td align="right">1.2&nbsp;</td><td><a href="#(part._.Lexer_.Abbreviations_and_.Macros)" class="tocviewlink" pltdoc="x">Lexer Abbreviations and Macros</a></td></tr><tr><td align="right">1.3&nbsp;</td><td><a href="#(part._.Lexer_.S.R.E_.Operators)" class="tocviewlink" pltdoc="x">Lexer SRE Operators</a></td></tr><tr><td align="right">1.4&nbsp;</td><td><a href="#(part._.Lexer_.Legacy_.Operators)" class="tocviewlink" pltdoc="x">Lexer Legacy Operators</a></td></tr><tr><td align="right">1.5&nbsp;</td><td><a href="#(part._.Tokens)" class="tocviewlink" pltdoc="x">Tokens</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#(part._.Creating_a_.Lexer)" class="tocsubseclink" pltdoc="x">Creating a Lexer</a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._lexer))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">lexer</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._lexer-src-pos))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">lexer-<wbr></wbr>src-<wbr></wbr>pos</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._start-pos))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">start-<wbr></wbr>pos</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._end-pos))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">end-<wbr></wbr>pos</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._lexeme))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">lexeme</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._input-port))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">input-<wbr></wbr>port</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._return-without-pos))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">return-<wbr></wbr>without-<wbr></wbr>pos</span></span></span></a></td></tr><tr><td><a href="#(def._((lib._parser-tools/lex..rkt)._position))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktValLink">position</span></span></span></a></td></tr><tr><td><a href="#(def._((lib._parser-tools/lex..rkt)._position-token))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktValLink">position-<wbr></wbr>token</span></span></span></a></td></tr><tr><td><a href="#(def._((lib._parser-tools/lex..rkt)._file-path))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktValLink">file-<wbr></wbr>path</span></span></span></a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#(part._.Lexer_.Abbreviations_and_.Macros)" class="tocsubseclink" pltdoc="x">Lexer Abbreviations and Macros</a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._char-set))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">char-<wbr></wbr>set</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._any-char))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">any-<wbr></wbr>char</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._any-string))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">any-<wbr></wbr>string</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._nothing))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">nothing</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._alphabetic))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">alphabetic</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._lower-case))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">lower-<wbr></wbr>case</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._upper-case))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">upper-<wbr></wbr>case</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._title-case))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">title-<wbr></wbr>case</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._symbolic))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">symbolic</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._punctuation))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">punctuation</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._graphic))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">graphic</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._whitespace))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">whitespace</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._blank))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">blank</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._iso-control))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">iso-<wbr></wbr>control</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._define-lex-abbrev))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">define-<wbr></wbr>lex-<wbr></wbr>abbrev</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._define-lex-abbrevs))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">define-<wbr></wbr>lex-<wbr></wbr>abbrevs</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._define-lex-trans))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">define-<wbr></wbr>lex-<wbr></wbr>trans</span></span></span></a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#(part._.Lexer_.S.R.E_.Operators)" class="tocsubseclink" pltdoc="x">Lexer SRE Operators</a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex-sre..rkt)._*))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><span class="RktStxLink">*</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex-sre..rkt)._+))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><span class="RktStxLink">+<span class="mywbr"> </span></span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~3f))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><span class="RktStxLink">?</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~3d))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><span class="RktStxLink">=</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~3e~3d))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><span class="RktStxLink">&gt;=</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex-sre..rkt)._**))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><span class="RktStxLink">**</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex-sre..rkt)._or))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><span class="RktStxLink">or</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~3a))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><span class="RktStxLink">:<span class="mywbr"> </span></span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex-sre..rkt)._seq))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><span class="RktStxLink">seq</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~26))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><span class="RktStxLink">&amp;</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex-sre..rkt)._-))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><span class="RktStxLink">-<wbr></wbr></span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~7e))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><span class="RktStxLink">~</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex-sre..rkt)._/))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><span class="RktStxLink">/<span class="mywbr"> </span></span></span></span></a></td></tr><tr><td><span class="tocsublinknumber">1.4<tt>&nbsp;</tt></span><a href="#(part._.Lexer_.Legacy_.Operators)" class="tocsubseclink" pltdoc="x">Lexer Legacy Operators</a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex-plt-v200..rkt)._epsilon))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex-plt-v200"><span class="RktSym"><span class="RktStxLink">epsilon</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex-plt-v200..rkt)._~7e))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex-plt-v200"><span class="RktSym"><span class="RktStxLink">~</span></span></span></a></td></tr><tr><td><span class="tocsublinknumber">1.5<tt>&nbsp;</tt></span><a href="#(part._.Tokens)" class="tocsubseclink" pltdoc="x">Tokens</a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._define-tokens))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">define-<wbr></wbr>tokens</span></span></span></a></td></tr><tr><td><a href="#(form._((lib._parser-tools/lex..rkt)._define-empty-tokens))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktStxLink">define-<wbr></wbr>empty-<wbr></wbr>tokens</span></span></span></a></td></tr><tr><td><a href="#(def._((lib._parser-tools/lex..rkt)._token-name))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktValLink">token-<wbr></wbr>name</span></span></span></a></td></tr><tr><td><a href="#(def._((lib._parser-tools/lex..rkt)._token-value))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktValLink">token-<wbr></wbr>value</span></span></span></a></td></tr><tr><td><a href="#(def._((lib._parser-tools/lex..rkt)._token~3f))" class="tocsubnonseclink" pltdoc="x"><span title="Provided from: parser-tools/lex"><span class="RktSym"><span class="RktValLink">token?</span></span></span></a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><form class="searchform"><input class="searchbox" style="color: #888;" type="text" value="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;5.0.2&quot;, &quot;../&quot;);" onfocus="this.style.color=&quot;black&quot;; this.style.textAlign=&quot;left&quot;; if (this.value == &quot;...search manuals...&quot;) this.value=&quot;&quot;;" onblur="if (this.value.match(/^ *$/)) { this.style.color=&quot;#888&quot;; this.style.textAlign=&quot;center&quot;; this.value=&quot;...search manuals...&quot;; }" /></form>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" pltdoc="x" onclick="return GotoPLTRoot(&quot;5.0.2&quot;);">top</a></span><span class="navright"><a href="index.html" title="backward to &quot;Parser Tools: lex and yacc-style Parsing&quot;" pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Parser Tools: lex and yacc-style Parsing&quot;" pltdoc="x">up</a>&nbsp;&nbsp;<a href="Parsers.html" title="forward to &quot;2 Parsers&quot;" pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>1<tt>&nbsp;</tt><a name="(part._.Lexers)"></a><a name="(mod-path._parser-tools/lex)"></a>Lexers</h3><p><table cellspacing="0" class="defmodule"><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/require.html#(form._((lib._racket/private/base..rkt)._require))" class="RktStxLink" pltdoc="x">require</a></span><span class="stt"> </span><a href="" class="RktModLink" pltdoc="x"><span class="RktSym">parser-tools/lex</span></a><span class="RktPn">)</span></td></tr></table></p><h4>1.1<tt>&nbsp;</tt><a name="(part._.Creating_a_.Lexer)"></a>Creating a Lexer</h4><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex..rkt)._lexer))"></a><a name="(form._((lib._parser-tools/lex..rkt)._lexer))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._lexer))" class="RktStxLink" pltdoc="x">lexer</a></span></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktVar">trigger</span><span class="hspace">&nbsp;</span><span class="RktVar">action-expr</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr><tr><td><span class="stt">&nbsp;</span></td></tr><tr><td><table cellspacing="0" class="specgrammar"><tr><td align="right" valign="baseline"><span class="RktVar">trigger</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">=</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktVar">re</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym"><a href="../reference/port-ops.html#(def._((quote._~23~25kernel)._eof))" class="RktValLink" pltdoc="x">eof</a></span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">special</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">special-comment</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td></tr><tr><td align="right" valign="baseline"><span class="RktVar">re</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">=</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktVar">id</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktVar">string</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktVar">character</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">repetition</span><span class="hspace">&nbsp;</span><span class="RktVar">lo</span><span class="hspace">&nbsp;</span><span class="RktVar">hi</span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">union</span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">intersection</span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">complement</span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">concatenation</span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">char-range</span><span class="hspace">&nbsp;</span><span class="RktVar">char</span><span class="hspace">&nbsp;</span><span class="RktVar">char</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">char-complement</span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktVar">id</span><span class="hspace">&nbsp;</span><span class="RktVar">datum</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr></table></td></tr></table></div><div class="SIntrapara">Produces a function that takes an input-port, matches the
     <span class="RktVar">re</span>&rsquo;s against the buffer, and returns the result of
     executing the corresponding <span class="RktVar">action-expr</span>.</div></p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>The implementation of <a href="../syntax-color/index.html#(mod-path._syntax-color/scheme-lexer)" class="RktModLink" pltdoc="x"><span class="RktSym">syntax-color/scheme-lexer</span></a>
contains a lexer for the <a href="../scheme/scheme.html" class="RktModLink" pltdoc="x"><span class="RktSym">scheme</span></a> language.
In addition, files in the <span class="stt">"examples"</span> sub-directory
of the <span class="stt">"parser-tools"</span> collection contain
simpler example lexers.</p></blockquote></blockquote></blockquote><p>An <span class="RktVar">re</span> is matched as follows:</p><ul><li><p><span class="RktVar">id</span>  &ndash;  expands to the named <a name="(tech._lexer._abbreviation)"></a><span style="font-style: italic">lexer abbreviation</span>;
abbreviations are defined via <span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._define-lex-abbrev))" class="RktStxLink" pltdoc="x">define-lex-abbrev</a></span> or supplied by modules
like <a href="#(mod-path._parser-tools/lex-sre)" class="RktModLink" pltdoc="x"><span class="RktSym">parser-tools/lex-sre</span></a>.</p></li><li><p><span class="RktVar">string</span>  &ndash;  matches the sequence of characters in <span class="RktVar">string</span>.</p></li><li><p><span class="RktVar">character</span>  &ndash;  matches a literal <span class="RktVar">character</span>.</p></li><li><p><span class="RktPn">(</span><span class="RktSym">repetition</span><span class="stt"> </span><span class="RktVar">lo</span><span class="stt"> </span><span class="RktVar">hi</span><span class="stt"> </span><span class="RktVar">re</span><span class="RktPn">)</span>  &ndash;  matches <span class="RktVar">re</span> repeated between <span class="RktVar">lo</span>
and <span class="RktVar">hi</span> times, inclusive; <span class="RktVar">hi</span> can be <span class="RktVal">+inf.0</span> for unbounded repetitions.</p></li><li><p><span class="RktPn">(</span><span class="RktSym">union</span><span class="stt"> </span><span class="RktVar">re</span><span class="stt"> </span><span class="RktMeta"><a href="../reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" class="RktStxLink" pltdoc="x">...</a></span><span class="RktPn">)</span>  &ndash;  matches if any of the sub-expressions match</p></li><li><p><span class="RktPn">(</span><span class="RktSym">intersection</span><span class="stt"> </span><span class="RktVar">re</span><span class="stt"> </span><span class="RktMeta"><a href="../reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" class="RktStxLink" pltdoc="x">...</a></span><span class="RktPn">)</span>  &ndash;  matches if all of the <span class="RktVar">re</span>s match.</p></li><li><p><span class="RktPn">(</span><span class="RktSym">complement</span><span class="stt"> </span><span class="RktVar">re</span><span class="RktPn">)</span>  &ndash;  matches anything that <span class="RktVar">re</span> does not.</p></li><li><p><span class="RktPn">(</span><span class="RktSym">concatenation</span><span class="stt"> </span><span class="RktVar">re</span><span class="stt"> </span><span class="RktMeta"><a href="../reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" class="RktStxLink" pltdoc="x">...</a></span><span class="RktPn">)</span>  &ndash;  matches each <span class="RktVar">re</span> in succession.</p></li><li><p><span class="RktPn">(</span><span class="RktSym">char-range</span><span class="stt"> </span><span class="RktVar">char</span><span class="stt"> </span><span class="RktVar">char</span><span class="RktPn">)</span>  &ndash;  matches any character between the two (inclusive);
a single character string can be used as a <span class="RktVar">char</span>.</p></li><li><p><span class="RktPn">(</span><span class="RktSym">char-complement</span><span class="stt"> </span><span class="RktVar">re</span><span class="RktPn">)</span>  &ndash;  matches any character not matched by <span class="RktVar">re</span>.
The sub-expression must be a set of characters <span class="RktVar">re</span>.</p></li><li><p><span class="RktPn">(</span><span class="RktVar">id</span><span class="stt"> </span><span class="RktVar">datum</span><span class="stt"> </span><span class="RktMeta"><a href="../reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" class="RktStxLink" pltdoc="x">...</a></span><span class="RktPn">)</span>  &ndash;  expands the <a name="(tech._lexer._macro)"></a><span style="font-style: italic">lexer macro</span> named <span class="RktVar">id</span>; macros
are defined via <span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._define-lex-trans))" class="RktStxLink" pltdoc="x">define-lex-trans</a></span>.</p></li></ul><p>Note that both <span class="RktPn">(</span><span class="RktSym">concatenation</span><span class="RktPn">)</span> and <span class="RktVal">""</span> match the
empty string, <span class="RktPn">(</span><span class="RktSym">union</span><span class="RktPn">)</span> matches nothing,
<span class="RktPn">(</span><span class="RktSym">intersection</span><span class="RktPn">)</span> matches any string, and
<span class="RktPn">(</span><span class="RktSym">char-complement</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">union</span><span class="RktPn">)</span><span class="RktPn">)</span> matches any single character.</p><p>The regular expression language is not designed to be used directly,
but rather as a basis for a user-friendly notation written with
regular expression macros.  For example,
<a href="#(mod-path._parser-tools/lex-sre)" class="RktModLink" pltdoc="x"><span class="RktSym">parser-tools/lex-sre</span></a> supplies operators from Olin
Shivers&rsquo;s SREs, and <a href="#(mod-path._parser-tools/lex-plt-v200)" class="RktModLink" pltdoc="x"><span class="RktSym">parser-tools/lex-plt-v200</span></a> supplies
(deprecated) operators from the previous version of this library.
Since those libraries provide operators whose names match other Scheme
bindings, such as <span class="RktSym"><a href="../reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))" class="RktValLink" pltdoc="x">*</a></span> and <span class="RktSym"><a href="../reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" class="RktValLink" pltdoc="x">+</a></span>, they normally must be
imported using a prefix:</p><p><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/require.html#(form._((lib._racket/private/base..rkt)._require))" class="RktStxLink" pltdoc="x">require</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/require.html#(form._((lib._racket/private/base..rkt)._prefix-in))" class="RktStxLink" pltdoc="x">prefix-in</a></span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">parser-tools/lex-sre</span><span class="RktPn">)</span><span class="RktPn">)</span></p><p>The suggested prefix is <span class="RktSym">:</span>, so that <span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._*))" class="RktStxLink" pltdoc="x">:*</a></span> and
<span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._+))" class="RktStxLink" pltdoc="x">:+</a></span> are imported.  Of course, a prefix other than <span class="RktSym">:</span>
(such as <span class="RktSym">re-</span>) will work too.</p><p>Since negation is not a common operator on regular expressions, here
are a few examples, using <span class="RktSym">:</span> prefixed SRE syntax:</p><ul><li><p><span class="RktPn">(</span><span class="RktSym">complement</span><span class="hspace">&nbsp;</span><span class="RktVal">"1"</span><span class="RktPn">)</span></p><p>Matches all strings except the string <span class="RktVal">"1"</span>, including
<span class="RktVal">"11"</span>, <span class="RktVal">"111"</span>, <span class="RktVal">"0"</span>, <span class="RktVal">"01"</span>,
<span class="RktVal">""</span>, and so on.</p></li><li><p><span class="RktPn">(</span><span class="RktSym">complement</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._*))" class="RktStxLink" pltdoc="x">:*</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"1"</span><span class="RktPn">)</span><span class="RktPn">)</span></p><p>Matches all strings that are not sequences of <span class="RktVal">"1"</span>,
including <span class="RktVal">"0"</span>, <span class="RktVal">"00"</span>, <span class="RktVal">"11110"</span>,
<span class="RktVal">"0111"</span>, <span class="RktVal">"11001010"</span> and so on.</p></li><li><p><table cellspacing="0" style="display: inline-table; vertical-align: text-top;" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~26))" class="RktStxLink" pltdoc="x">:&amp;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~3a))" class="RktStxLink" pltdoc="x">::</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._any-string))" class="RktStxLink" pltdoc="x">any-string</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"111"</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._any-string))" class="RktStxLink" pltdoc="x">any-string</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">complement</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._or))" class="RktStxLink" pltdoc="x">:or</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~3a))" class="RktStxLink" pltdoc="x">::</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._any-string))" class="RktStxLink" pltdoc="x">any-string</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"01"</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._+))" class="RktStxLink" pltdoc="x">:+</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"1"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></p><p>Matches all strings that have 3 consecutive ones, but not those that
end in <span class="RktVal">"01"</span> and not those that are ones only.  These
include <span class="RktVal">"1110"</span>, <span class="RktVal">"0001000111"</span> and <span class="RktVal">"0111"</span>
but not <span class="RktVal">""</span>, <span class="RktVal">"11"</span>, <span class="RktVal">"11101"</span>, <span class="RktVal">"111"</span>
and <span class="RktVal">"11111"</span>.</p></li><li><p><span class="RktPn">(</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~3a))" class="RktStxLink" pltdoc="x">::</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"/*"</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">complement</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~3a))" class="RktStxLink" pltdoc="x">::</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._any-string))" class="RktStxLink" pltdoc="x">any-string</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"*/"</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._any-string))" class="RktStxLink" pltdoc="x">any-string</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">"*/"</span><span class="RktPn">)</span></p><p>Matches Java/C block comments.  <span class="RktVal">"/**/"</span>,
<span class="RktVal">"/******/"</span>, <span class="RktVal">"/*////*/"</span>, <span class="RktVal">"/*asg4*/"</span> and so
on.  It does not match <span class="RktVal">"/**/*/"</span>, <span class="RktVal">"/* */ */"</span> and so
on.  <span class="RktPn">(</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~3a))" class="RktStxLink" pltdoc="x">::</a></span><span class="stt"> </span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._any-string))" class="RktStxLink" pltdoc="x">any-string</a></span><span class="stt"> </span><span class="RktVal">"*/"</span><span class="stt"> </span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._any-string))" class="RktStxLink" pltdoc="x">any-string</a></span><span class="RktPn">)</span> matches any string
that has a <span class="RktVal">"*/"</span> in is, so <span class="RktPn">(</span><span class="RktSym">complement</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~3a))" class="RktStxLink" pltdoc="x">::</a></span><span class="stt"> </span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._any-string))" class="RktStxLink" pltdoc="x">any-string</a></span><span class="stt"> </span><span class="RktVal">"*/"</span><span class="stt"> </span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._any-string))" class="RktStxLink" pltdoc="x">any-string</a></span><span class="RktPn">)</span><span class="RktPn">)</span> matches any string without a <span class="RktVal">"*/"</span> in it.</p></li><li><p><span class="RktPn">(</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~3a))" class="RktStxLink" pltdoc="x">::</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"/*"</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._*))" class="RktStxLink" pltdoc="x">:*</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">complement</span><span class="hspace">&nbsp;</span><span class="RktVal">"*/"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">"*/"</span><span class="RktPn">)</span></p><p>Matches any string that starts with <span class="RktVal">"/*"</span> and ends with
<span class="RktVal">"*/"</span>, including <span class="RktVal">"/* */ */ */"</span>.
<span class="RktPn">(</span><span class="RktSym">complement</span><span class="stt"> </span><span class="RktVal">"*/"</span><span class="RktPn">)</span> matches any string except <span class="RktVal">"*/"</span>.
This includes <span class="RktVal">"*"</span> and <span class="RktVal">"/"</span> separately.  Thus
<span class="RktPn">(</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._*))" class="RktStxLink" pltdoc="x">:*</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">complement</span><span class="stt"> </span><span class="RktVal">"*/"</span><span class="RktPn">)</span><span class="RktPn">)</span> matches <span class="RktVal">"*/"</span> by first
matching <span class="RktVal">"*"</span> and then matching <span class="RktVal">"/"</span>.  Any other
string is matched directly by <span class="RktPn">(</span><span class="RktSym">complement</span><span class="stt"> </span><span class="RktVal">"*/"</span><span class="RktPn">)</span>.  In other
words, <span class="RktPn">(</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._*))" class="RktStxLink" pltdoc="x">:*</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">complement</span><span class="stt"> </span><span class="RktVal">"xx"</span><span class="RktPn">)</span><span class="RktPn">)</span> = <span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._any-string))" class="RktStxLink" pltdoc="x">any-string</a></span>.  It is
usually not correct to place a <span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._*))" class="RktStxLink" pltdoc="x">:*</a></span> around a
<span class="RktSym">complement</span>.</p></li></ul><p>The following binding have special meaning inside of a lexer
     action:</p><ul><li><p><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._start-pos))" class="RktStxLink" pltdoc="x">start-pos</a></span>  &ndash;  a <span class="RktSym"><a href="#(def._((lib._parser-tools/lex..rkt)._position))" class="RktValLink" pltdoc="x">position</a></span> struct for the first character matched.</p></li><li><p><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._end-pos))" class="RktStxLink" pltdoc="x">end-pos</a></span>  &ndash;  a <span class="RktSym"><a href="#(def._((lib._parser-tools/lex..rkt)._position))" class="RktValLink" pltdoc="x">position</a></span> struct for the character after the last character in the match.</p></li><li><p><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._lexeme))" class="RktStxLink" pltdoc="x">lexeme</a></span>  &ndash;  the matched string.</p></li><li><p><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._input-port))" class="RktStxLink" pltdoc="x">input-port</a></span>  &ndash;  the input-port being
processed (this is useful for matching input with multiple
lexers).</p></li><li><p><span class="RktPn">(</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._return-without-pos))" class="RktStxLink" pltdoc="x">return-without-pos</a></span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">)</span> is a function (continuation) that
immediately returns the value of <span class="RktSym">x</span> from the lexer.  This useful
in a src-pos lexer to prevent the lexer from adding source
information.  For example:</p><p><table cellspacing="0" class="RktBlk"><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/define.html#(form._((lib._racket/private/base..rkt)._define))" class="RktStxLink" pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">get-token</span></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._lexer-src-pos))" class="RktStxLink" pltdoc="x">lexer-src-pos</a></span></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"><a href="../reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" class="RktStxLink" pltdoc="x">...</a></span></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">comment</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">get-token</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._input-port))" class="RktStxLink" pltdoc="x">input-port</a></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"><a href="../reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" class="RktStxLink" pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></p><p>would wrap the source location information for the comment around
the value of the recursive call.  Using
<span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">comment</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._return-without-pos))" class="RktStxLink" pltdoc="x">return-without-pos</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">get-token</span><span class="stt"> </span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._input-port))" class="RktStxLink" pltdoc="x">input-port</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span>
will cause the value of the recursive call to be returned without
wrapping position around it.</p></li></ul><p>The lexer raises an exception <span class="RktPn">(</span><span class="RktSym">exn:read</span><span class="RktPn">)</span> if none of the
     regular expressions match the input.  Hint: If <span class="RktPn">(</span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._any-char))" class="RktStxLink" pltdoc="x">any-char</a></span><span class="stt"> </span><span class="RktVar">custom-error-behavior</span><span class="RktPn">)</span> is the last rule, then there will always
     be a match, and <span class="RktVar">custom-error-behavior</span> is executed to
     handle the error situation as desired, only consuming the first
     character from the input buffer.</p><p>In addition to returning characters, input
     ports can return <span class="RktSym">eof-object</span>s.  Custom input ports can
     also return a <span class="RktSym">special-comment</span> value to indicate a
     non-textual comment, or return another arbitrary value (a
     special). The non-<span class="RktVar">re</span> <span class="RktVar">trigger</span> forms handle these
     cases:</p><ul><li><p>The <span class="RktPn">(</span><span class="RktSym"><a href="../reference/port-ops.html#(def._((quote._~23~25kernel)._eof))" class="RktValLink" pltdoc="x">eof</a></span><span class="RktPn">)</span> rule is matched when the input port
returns an <span class="RktSym">eof-object</span> value.  If no <span class="RktPn">(</span><span class="RktSym"><a href="../reference/port-ops.html#(def._((quote._~23~25kernel)._eof))" class="RktValLink" pltdoc="x">eof</a></span><span class="RktPn">)</span>
rule is present, the lexer returns the symbol <span class="RktVal">'</span><span class="RktVal">eof</span>
when the port returns an <span class="RktSym">eof-object</span> value.</p></li><li><p>The <span class="RktPn">(</span><span class="RktSym">special-comment</span><span class="RktPn">)</span> rule is matched when the
input port returns a <span class="RktSym">special-comment</span> structure.  If no
<span class="RktSym">special-comment</span> rule is present, the lexer
automatically tries to return the next token from the input
port.</p></li><li><p>The <span class="RktPn">(</span><span class="RktSym">special</span><span class="RktPn">)</span> rule is matched when the input
port returns a value other than a character,
<span class="RktSym">eof-object</span>, or <span class="RktSym">special-comment</span> structure.  If
no <span class="RktPn">(</span><span class="RktSym">special</span><span class="RktPn">)</span> rule is present, the lexer returns
<span class="RktPn">(</span><span class="RktSym"><a href="../reference/void.html#(def._((quote._~23~25kernel)._void))" class="RktValLink" pltdoc="x">void</a></span><span class="RktPn">)</span>.</p></li></ul><p>End-of-files, specials, special-comments and special-errors cannot
    be parsed via a rule using an ordinary regular expression
    (but dropping down and manipulating the port to handle them
     is possible in some situations).</p><p>Since the lexer gets its source information from the port, use
    <span class="RktSym"><a href="../reference/linecol.html#(def._((quote._~23~25kernel)._port-count-lines!))" class="RktValLink" pltdoc="x">port-count-lines!</a></span> to enable the tracking of line and
    column information.  Otherwise, the line and column information
    will return <span class="RktVal">#f</span>.</p><p>When peeking from the input port raises an exception (such as by
    an embedded XML editor with malformed syntax), the exception can
    be raised before all tokens preceding the exception have been
    returned.</p><p>Each time the scheme code for a lexer is compiled (e.g. when a
    <span class="stt">".ss"</span> file containing a <span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._lexer))" class="RktStxLink" pltdoc="x">lexer</a></span> form is loaded),
    the lexer generator is run.  To avoid this overhead place the
    lexer into a module and compile the module to a <span class="stt">".zo"</span>
    bytecode file.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex..rkt)._lexer-src-pos))"></a><a name="(form._((lib._parser-tools/lex..rkt)._lexer-src-pos))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._lexer-src-pos))" class="RktStxLink" pltdoc="x">lexer-src-pos</a></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">trigger</span><span class="hspace">&nbsp;</span><span class="RktVar">action-expr</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">Like <span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._lexer))" class="RktStxLink" pltdoc="x">lexer</a></span>, but for each <span class="RktVar">action-result</span> produced by
an <span class="RktVar">action-expr</span>, returns <span class="RktPn">(</span><span class="RktSym"><a href="#(def._((lib._parser-tools/lex..rkt)._make-position-token))" class="RktValLink" pltdoc="x">make-position-token</a></span><span class="stt"> </span><span class="RktVar">action-result</span><span class="stt"> </span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._start-pos))" class="RktStxLink" pltdoc="x">start-pos</a></span><span class="stt"> </span><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._end-pos))" class="RktStxLink" pltdoc="x">end-pos</a></span><span class="RktPn">)</span> instead of simply
<span class="RktVar">action-result</span>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0" class="together"><tr><td><a name="(dep._((lib._parser-tools/lex..rkt)._start-pos))"></a><a name="(form._((lib._parser-tools/lex..rkt)._start-pos))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._start-pos))" class="RktStxLink" pltdoc="x">start-pos</a></span></span></td></tr></table></td></tr><tr><td><table cellspacing="0" class="together"><tr><td><a name="(dep._((lib._parser-tools/lex..rkt)._end-pos))"></a><a name="(form._((lib._parser-tools/lex..rkt)._end-pos))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._end-pos))" class="RktStxLink" pltdoc="x">end-pos</a></span></span></td></tr></table></td></tr><tr><td><table cellspacing="0" class="together"><tr><td><a name="(dep._((lib._parser-tools/lex..rkt)._lexeme))"></a><a name="(form._((lib._parser-tools/lex..rkt)._lexeme))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._lexeme))" class="RktStxLink" pltdoc="x">lexeme</a></span></span></td></tr></table></td></tr><tr><td><table cellspacing="0" class="together"><tr><td><a name="(dep._((lib._parser-tools/lex..rkt)._input-port))"></a><a name="(form._((lib._parser-tools/lex..rkt)._input-port))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._input-port))" class="RktStxLink" pltdoc="x">input-port</a></span></span></td></tr></table></td></tr><tr><td><table cellspacing="0" class="together"><tr><td><a name="(dep._((lib._parser-tools/lex..rkt)._return-without-pos))"></a><a name="(form._((lib._parser-tools/lex..rkt)._return-without-pos))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._return-without-pos))" class="RktStxLink" pltdoc="x">return-without-pos</a></span></span></td></tr></table></td></tr></table></div><div class="SIntrapara">Use of these names outside of a <span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._lexer))" class="RktStxLink" pltdoc="x">lexer</a></span> action is a syntax
error.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="../reference/define-struct.html#(form._((lib._racket/private/base..rkt)._struct))" class="RktStxLink" pltdoc="x">struct</a></span></td><td><span class="hspace">&nbsp;</span></td><td><a name="(dep._((lib._parser-tools/lex..rkt)._position-col))"></a><a name="(def._((lib._parser-tools/lex..rkt)._position-col))"></a><a name="(dep._((lib._parser-tools/lex..rkt)._position-line))"></a><a name="(def._((lib._parser-tools/lex..rkt)._position-line))"></a><a name="(dep._((lib._parser-tools/lex..rkt)._position-offset))"></a><a name="(def._((lib._parser-tools/lex..rkt)._position-offset))"></a><a name="(dep._((lib._parser-tools/lex..rkt)._make-position))"></a><a name="(def._((lib._parser-tools/lex..rkt)._make-position))"></a><a name="(dep._((lib._parser-tools/lex..rkt)._position~3f))"></a><a name="(def._((lib._parser-tools/lex..rkt)._position~3f))"></a><a name="(dep._((lib._parser-tools/lex..rkt)._struct~3aposition))"></a><a name="(def._((lib._parser-tools/lex..rkt)._struct~3aposition))"></a><a name="(dep._((lib._parser-tools/lex..rkt)._position))"></a><a name="(def._((lib._parser-tools/lex..rkt)._position))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(def._((lib._parser-tools/lex..rkt)._position))" class="RktValLink" pltdoc="x">position</a></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">offset</span><span class="stt"> </span><span class="RktSym">line</span><span class="stt"> </span><span class="RktSym">col</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="#(def._((lib._parser-tools/lex..rkt)._make-position))" class="RktValLink" pltdoc="x">make-position</a></span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">offset</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><a href="../reference/number-types.html#(def._((quote._~23~25kernel)._exact-positive-integer~3f))" class="RktValLink" pltdoc="x">exact-positive-integer?</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">line</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><a href="../reference/number-types.html#(def._((quote._~23~25kernel)._exact-positive-integer~3f))" class="RktValLink" pltdoc="x">exact-positive-integer?</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">col</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><a href="../reference/number-types.html#(def._((quote._~23~25kernel)._exact-nonnegative-integer~3f))" class="RktValLink" pltdoc="x">exact-nonnegative-integer?</a></span></td></tr></table></div><div class="SIntrapara">Instances of <span class="RktSym"><a href="#(def._((lib._parser-tools/lex..rkt)._position))" class="RktValLink" pltdoc="x">position</a></span> are bound to <span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._start-pos))" class="RktStxLink" pltdoc="x">start-pos</a></span> and
<span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._end-pos))" class="RktStxLink" pltdoc="x">end-pos</a></span>. The <span class="RktSym">offset</span> field contains the offset of
the character in the input.  The <span class="RktSym">line</span> field contains the
line number of the character.  The <span class="RktSym">col</span> field contains the
offset in the current line.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="../reference/define-struct.html#(form._((lib._racket/private/base..rkt)._struct))" class="RktStxLink" pltdoc="x">struct</a></span></td><td><span class="hspace">&nbsp;</span></td><td><a name="(dep._((lib._parser-tools/lex..rkt)._position-token-end-pos))"></a><a name="(def._((lib._parser-tools/lex..rkt)._position-token-end-pos))"></a><a name="(dep._((lib._parser-tools/lex..rkt)._position-token-start-pos))"></a><a name="(def._((lib._parser-tools/lex..rkt)._position-token-start-pos))"></a><a name="(dep._((lib._parser-tools/lex..rkt)._position-token-token))"></a><a name="(def._((lib._parser-tools/lex..rkt)._position-token-token))"></a><a name="(dep._((lib._parser-tools/lex..rkt)._make-position-token))"></a><a name="(def._((lib._parser-tools/lex..rkt)._make-position-token))"></a><a name="(dep._((lib._parser-tools/lex..rkt)._position-token~3f))"></a><a name="(def._((lib._parser-tools/lex..rkt)._position-token~3f))"></a><a name="(dep._((lib._parser-tools/lex..rkt)._struct~3aposition-token))"></a><a name="(def._((lib._parser-tools/lex..rkt)._struct~3aposition-token))"></a><a name="(dep._((lib._parser-tools/lex..rkt)._position-token))"></a><a name="(def._((lib._parser-tools/lex..rkt)._position-token))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(def._((lib._parser-tools/lex..rkt)._position-token))" class="RktValLink" pltdoc="x">position-token</a></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">token</span><span class="stt"> </span><span class="RktSym">start-pos</span><span class="stt"> </span><span class="RktSym">end-pos</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td><td><span class="hspace">&nbsp;</span></td><td><span class="RktPn">#:extra-constructor-name</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="#(def._((lib._parser-tools/lex..rkt)._make-position-token))" class="RktValLink" pltdoc="x">make-position-token</a></span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">token</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><a href="../reference/Data-structure_Contracts.html#(def._((lib._racket/contract/private/guts..rkt)._any/c))" class="RktValLink" pltdoc="x">any/c</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">start-pos</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><a href="#(def._((lib._parser-tools/lex..rkt)._position~3f))" class="RktValLink" pltdoc="x">position?</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">end-pos</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><a href="#(def._((lib._parser-tools/lex..rkt)._position~3f))" class="RktValLink" pltdoc="x">position?</a></span></td></tr></table></div><div class="SIntrapara">Lexers created with <span class="RktSym">src-pos-lexers</span> return instances of <span class="RktSym"><a href="#(def._((lib._parser-tools/lex..rkt)._position-token))" class="RktValLink" pltdoc="x">position-token</a></span>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex..rkt)._file-path))"></a><a name="(def._((lib._parser-tools/lex..rkt)._file-path))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(def._((lib._parser-tools/lex..rkt)._file-path))" class="RktValLink" pltdoc="x">file-path</a></span></span><span class="RktPn"></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym"><a href="../reference/Data-structure_Contracts.html#(def._((lib._racket/contract/private/guts..rkt)._any/c))" class="RktValLink" pltdoc="x">any/c</a></span></td></tr><tr><td><span class="RktPn">(</span><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(def._((lib._parser-tools/lex..rkt)._file-path))" class="RktValLink" pltdoc="x">file-path</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">source</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym"><a href="../reference/void.html#(def._((quote._~23~25kernel)._void~3f))" class="RktValLink" pltdoc="x">void?</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">source</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><a href="../reference/Data-structure_Contracts.html#(def._((lib._racket/contract/private/guts..rkt)._any/c))" class="RktValLink" pltdoc="x">any/c</a></span></td></tr></table></div><div class="SIntrapara">A parameter that the lexer uses as the source location if it
raises a <span class="RktSym">exn:fail:rad</span> error.  Setting this parameter allows
DrRacket, for example, to open the file containing the error.</div></p><h4>1.2<tt>&nbsp;</tt><a name="(part._.Lexer_.Abbreviations_and_.Macros)"></a>Lexer Abbreviations and Macros</h4><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex..rkt)._char-set))"></a><a name="(form._((lib._parser-tools/lex..rkt)._char-set))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._char-set))" class="RktStxLink" pltdoc="x">char-set</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">string</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">A <a href="#(tech._lexer._macro)" class="techoutside" pltdoc="x"><span class="techinside">lexer macro</span></a> that matches any character in <span class="RktVar">string</span>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><a name="(dep._((lib._parser-tools/lex..rkt)._any-char))"></a><a name="(form._((lib._parser-tools/lex..rkt)._any-char))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._any-char))" class="RktStxLink" pltdoc="x">any-char</a></span></span></td></tr></table></div><div class="SIntrapara">A <a href="#(tech._lexer._abbreviation)" class="techoutside" pltdoc="x"><span class="techinside">lexer abbreviation</span></a> that matches any character.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><a name="(dep._((lib._parser-tools/lex..rkt)._any-string))"></a><a name="(form._((lib._parser-tools/lex..rkt)._any-string))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._any-string))" class="RktStxLink" pltdoc="x">any-string</a></span></span></td></tr></table></div><div class="SIntrapara">A <a href="#(tech._lexer._abbreviation)" class="techoutside" pltdoc="x"><span class="techinside">lexer abbreviation</span></a> that matches any string.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><a name="(dep._((lib._parser-tools/lex..rkt)._nothing))"></a><a name="(form._((lib._parser-tools/lex..rkt)._nothing))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._nothing))" class="RktStxLink" pltdoc="x">nothing</a></span></span></td></tr></table></div><div class="SIntrapara">A <a href="#(tech._lexer._abbreviation)" class="techoutside" pltdoc="x"><span class="techinside">lexer abbreviation</span></a> that matches no string.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0" class="together"><tr><td><a name="(dep._((lib._parser-tools/lex..rkt)._alphabetic))"></a><a name="(form._((lib._parser-tools/lex..rkt)._alphabetic))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._alphabetic))" class="RktStxLink" pltdoc="x">alphabetic</a></span></span></td></tr></table></td></tr><tr><td><table cellspacing="0" class="together"><tr><td><a name="(dep._((lib._parser-tools/lex..rkt)._lower-case))"></a><a name="(form._((lib._parser-tools/lex..rkt)._lower-case))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._lower-case))" class="RktStxLink" pltdoc="x">lower-case</a></span></span></td></tr></table></td></tr><tr><td><table cellspacing="0" class="together"><tr><td><a name="(dep._((lib._parser-tools/lex..rkt)._upper-case))"></a><a name="(form._((lib._parser-tools/lex..rkt)._upper-case))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._upper-case))" class="RktStxLink" pltdoc="x">upper-case</a></span></span></td></tr></table></td></tr><tr><td><table cellspacing="0" class="together"><tr><td><a name="(dep._((lib._parser-tools/lex..rkt)._title-case))"></a><a name="(form._((lib._parser-tools/lex..rkt)._title-case))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._title-case))" class="RktStxLink" pltdoc="x">title-case</a></span></span></td></tr></table></td></tr><tr><td><table cellspacing="0" class="together"><tr><td><a name="(dep._((lib._parser-tools/lex..rkt)._symbolic))"></a><a name="(form._((lib._parser-tools/lex..rkt)._symbolic))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._symbolic))" class="RktStxLink" pltdoc="x">symbolic</a></span></span></td></tr></table></td></tr><tr><td><table cellspacing="0" class="together"><tr><td><a name="(dep._((lib._parser-tools/lex..rkt)._punctuation))"></a><a name="(form._((lib._parser-tools/lex..rkt)._punctuation))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._punctuation))" class="RktStxLink" pltdoc="x">punctuation</a></span></span></td></tr></table></td></tr><tr><td><table cellspacing="0" class="together"><tr><td><a name="(dep._((lib._parser-tools/lex..rkt)._graphic))"></a><a name="(form._((lib._parser-tools/lex..rkt)._graphic))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._graphic))" class="RktStxLink" pltdoc="x">graphic</a></span></span></td></tr></table></td></tr><tr><td><table cellspacing="0" class="together"><tr><td><a name="(dep._((lib._parser-tools/lex..rkt)._whitespace))"></a><a name="(form._((lib._parser-tools/lex..rkt)._whitespace))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._whitespace))" class="RktStxLink" pltdoc="x">whitespace</a></span></span></td></tr></table></td></tr><tr><td><table cellspacing="0" class="together"><tr><td><a name="(dep._((lib._parser-tools/lex..rkt)._blank))"></a><a name="(form._((lib._parser-tools/lex..rkt)._blank))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._blank))" class="RktStxLink" pltdoc="x">blank</a></span></span></td></tr></table></td></tr><tr><td><table cellspacing="0" class="together"><tr><td><a name="(dep._((lib._parser-tools/lex..rkt)._iso-control))"></a><a name="(form._((lib._parser-tools/lex..rkt)._iso-control))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._iso-control))" class="RktStxLink" pltdoc="x">iso-control</a></span></span></td></tr></table></td></tr></table></div><div class="SIntrapara"><a href="#(tech._lexer._abbreviation)" class="techoutside" pltdoc="x"><span class="techinside">Lexer abbreviations</span></a> that match <span class="RktSym"><a href="../reference/characters.html#(def._((quote._~23~25kernel)._char-alphabetic~3f))" class="RktValLink" pltdoc="x">char-alphabetic?</a></span>
characters, <span class="RktSym"><a href="../reference/characters.html#(def._((quote._~23~25kernel)._char-lower-case~3f))" class="RktValLink" pltdoc="x">char-lower-case?</a></span> characters, etc.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex..rkt)._define-lex-abbrev))"></a><a name="(form._((lib._parser-tools/lex..rkt)._define-lex-abbrev))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._define-lex-abbrev))" class="RktStxLink" pltdoc="x">define-lex-abbrev</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">id</span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">Defines a <a href="#(tech._lexer._abbreviation)" class="techoutside" pltdoc="x"><span class="techinside">lexer abbreviation</span></a> by associating a regular
expression to be used in place of the <span class="RktVar">id</span> in other
regular expression.  The definition of name has the same scoping
properties as a other syntactic binding (e.g., it can be exported
from a module).</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex..rkt)._define-lex-abbrevs))"></a><a name="(form._((lib._parser-tools/lex..rkt)._define-lex-abbrevs))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._define-lex-abbrevs))" class="RktStxLink" pltdoc="x">define-lex-abbrevs</a></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">id</span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">Like <span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._define-lex-abbrev))" class="RktStxLink" pltdoc="x">define-lex-abbrev</a></span>, but defines several <a href="#(tech._lexer._abbreviation)" class="techoutside" pltdoc="x"><span class="techinside">lexer
abbreviations</span></a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex..rkt)._define-lex-trans))"></a><a name="(form._((lib._parser-tools/lex..rkt)._define-lex-trans))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._define-lex-trans))" class="RktStxLink" pltdoc="x">define-lex-trans</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">id</span><span class="hspace">&nbsp;</span><span class="RktVar">trans-expr</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">Defines a <a href="#(tech._lexer._macro)" class="techoutside" pltdoc="x"><span class="techinside">lexer macro</span></a>, where <span class="RktVar">trans-expr</span> produces a
transformer procedure that takes one argument.  When <span class="RktPn">(</span><span class="RktVar">id</span><span class="stt"> </span><span class="RktVar">datum</span><span class="stt"> </span><span class="RktMeta"><a href="../reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" class="RktStxLink" pltdoc="x">...</a></span><span class="RktPn">)</span> appears as a regular expression, it is replaced with
the result of applying the transformer to the expression.</div></p><h4>1.3<tt>&nbsp;</tt><a name="(part._.Lexer_.S.R.E_.Operators)"></a><a name="(mod-path._parser-tools/lex-sre)"></a>Lexer SRE Operators</h4><p><table cellspacing="0" class="defmodule"><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/require.html#(form._((lib._racket/private/base..rkt)._require))" class="RktStxLink" pltdoc="x">require</a></span><span class="stt"> </span><a href="#(mod-path._parser-tools/lex-sre)" class="RktModLink" pltdoc="x"><span class="RktSym">parser-tools/lex-sre</span></a><span class="RktPn">)</span></td></tr></table></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex-sre..rkt)._*))"></a><a name="(form._((lib._parser-tools/lex-sre..rkt)._*))"></a><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._*))" class="RktStxLink" pltdoc="x">*</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">Repetition of <span class="RktVar">re</span> sequence 0 or more times.</div><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex-sre..rkt)._+))"></a><a name="(form._((lib._parser-tools/lex-sre..rkt)._+))"></a><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._+))" class="RktStxLink" pltdoc="x">+</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">Repetition of <span class="RktVar">re</span> sequence 1 or more times.</div><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex-sre..rkt)._~3f))"></a><a name="(form._((lib._parser-tools/lex-sre..rkt)._~3f))"></a><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~3f))" class="RktStxLink" pltdoc="x">?</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">Zero or one occurrence of <span class="RktVar">re</span> sequence.</div><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex-sre..rkt)._~3d))"></a><a name="(form._((lib._parser-tools/lex-sre..rkt)._~3d))"></a><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~3d))" class="RktStxLink" pltdoc="x">=</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">n</span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">Exactly <span class="RktVar">n</span> occurrences of <span class="RktVar">re</span> sequence, where
<span class="RktVar">n</span> must be a literal exact, non-negative number.</div><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex-sre..rkt)._~3e~3d))"></a><a name="(form._((lib._parser-tools/lex-sre..rkt)._~3e~3d))"></a><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~3e~3d))" class="RktStxLink" pltdoc="x">&gt;=</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">n</span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">At least <span class="RktVar">n</span> occurrences of <span class="RktVar">re</span> sequence, where
<span class="RktVar">n</span> must be a literal exact, non-negative number.</div><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex-sre..rkt)._**))"></a><a name="(form._((lib._parser-tools/lex-sre..rkt)._**))"></a><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._**))" class="RktStxLink" pltdoc="x">**</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">n</span><span class="hspace">&nbsp;</span><span class="RktVar">m</span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">Between <span class="RktVar">n</span> and <span class="RktVar">m</span> (inclusive) occurrences of
<span class="RktVar">re</span> sequence, where <span class="RktVar">n</span> must be a literal exact,
non-negative number, and <span class="RktVar">m</span> must be literally either
<span class="RktVal">#f</span>, <span class="RktVal">+inf.0</span>, or an exact, non-negative number; a
<span class="RktVal">#f</span> value for <span class="RktVar">m</span> is the same as <span class="RktVal">+inf.0</span>.</div><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex-sre..rkt)._or))"></a><a name="(form._((lib._parser-tools/lex-sre..rkt)._or))"></a><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._or))" class="RktStxLink" pltdoc="x">or</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">Same as <span class="RktPn">(</span><span class="RktSym">union</span><span class="stt"> </span><span class="RktVar">re</span><span class="stt"> </span><span class="RktMeta"><a href="../reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" class="RktStxLink" pltdoc="x">...</a></span><span class="RktPn">)</span>.</div><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0" class="together"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex-sre..rkt)._~3a))"></a><a name="(form._((lib._parser-tools/lex-sre..rkt)._~3a))"></a><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~3a))" class="RktStxLink" pltdoc="x">:</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><table cellspacing="0" class="together"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex-sre..rkt)._seq))"></a><a name="(form._((lib._parser-tools/lex-sre..rkt)._seq))"></a><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._seq))" class="RktStxLink" pltdoc="x">seq</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr></table></td></tr></table></div><div class="SIntrapara">Both forms concatenate the <span class="RktVar">re</span>s.</div><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex-sre..rkt)._~26))"></a><a name="(form._((lib._parser-tools/lex-sre..rkt)._~26))"></a><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~26))" class="RktStxLink" pltdoc="x">&amp;</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">Intersects the <span class="RktVar">re</span>s.</div><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex-sre..rkt)._-))"></a><a name="(form._((lib._parser-tools/lex-sre..rkt)._-))"></a><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._-))" class="RktStxLink" pltdoc="x">-</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">The set difference of the <span class="RktVar">re</span>s.</div><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex-sre..rkt)._~7e))"></a><a name="(form._((lib._parser-tools/lex-sre..rkt)._~7e))"></a><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~7e))" class="RktStxLink" pltdoc="x">~</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">Character-set complement, which each <span class="RktVar">re</span> must match exactly
one character.</div><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex-sre..rkt)._/))"></a><a name="(form._((lib._parser-tools/lex-sre..rkt)._/))"></a><span title="Provided from: parser-tools/lex-sre"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._/))" class="RktStxLink" pltdoc="x">/</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">char-or-string</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">Character ranges, matching characters between successive pairs of
characters.</div></p><h4>1.4<tt>&nbsp;</tt><a name="(part._.Lexer_.Legacy_.Operators)"></a><a name="(mod-path._parser-tools/lex-plt-v200)"></a>Lexer Legacy Operators</h4><p><table cellspacing="0" class="defmodule"><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/require.html#(form._((lib._racket/private/base..rkt)._require))" class="RktStxLink" pltdoc="x">require</a></span><span class="stt"> </span><a href="#(mod-path._parser-tools/lex-plt-v200)" class="RktModLink" pltdoc="x"><span class="RktSym">parser-tools/lex-plt-v200</span></a><span class="RktPn">)</span></td></tr></table></p><p><div class="SIntrapara">The <a href="#(mod-path._parser-tools/lex-plt-v200)" class="RktModLink" pltdoc="x"><span class="RktSym">parser-tools/lex-plt-v200</span></a> module re-exports
<span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._*))" class="RktStxLink" pltdoc="x">*</a></span>, <span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._+))" class="RktStxLink" pltdoc="x">+</a></span>, <span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~3f))" class="RktStxLink" pltdoc="x">?</a></span>, and <span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~26))" class="RktStxLink" pltdoc="x">&amp;</a></span> from
<a href="#(mod-path._parser-tools/lex-sre)" class="RktModLink" pltdoc="x"><span class="RktSym">parser-tools/lex-sre</span></a>. It also re-exports
<span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._or))" class="RktStxLink" pltdoc="x">:or</a></span> as <span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._or))" class="RktStxLink" pltdoc="x">:</a></span>, <span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~3a))" class="RktStxLink" pltdoc="x">::</a></span> as <span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~3a))" class="RktStxLink" pltdoc="x">@</a></span>, <span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~7e))" class="RktStxLink" pltdoc="x">:~</a></span>
as <span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._~7e))" class="RktStxLink" pltdoc="x">^</a></span>, and <span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._/))" class="RktStxLink" pltdoc="x">:/</a></span> as <span class="RktSym"><a href="#(form._((lib._parser-tools/lex-sre..rkt)._/))" class="RktStxLink" pltdoc="x">-</a></span>.</div><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex-plt-v200..rkt)._epsilon))"></a><a name="(form._((lib._parser-tools/lex-plt-v200..rkt)._epsilon))"></a><span title="Provided from: parser-tools/lex-plt-v200"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-plt-v200..rkt)._epsilon))" class="RktStxLink" pltdoc="x">epsilon</a></span></span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">A <a href="#(tech._lexer._macro)" class="techoutside" pltdoc="x"><span class="techinside">lexer macro</span></a> that matches an empty sequence.</div><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex-plt-v200..rkt)._~7e))"></a><a name="(form._((lib._parser-tools/lex-plt-v200..rkt)._~7e))"></a><span title="Provided from: parser-tools/lex-plt-v200"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex-plt-v200..rkt)._~7e))" class="RktStxLink" pltdoc="x">~</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">re</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">The same as <span class="RktPn">(</span><span class="RktSym">complement</span><span class="stt"> </span><span class="RktVar">re</span><span class="stt"> </span><span class="RktMeta"><a href="../reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" class="RktStxLink" pltdoc="x">...</a></span><span class="RktPn">)</span>.</div></p><h4>1.5<tt>&nbsp;</tt><a name="(part._.Tokens)"></a>Tokens</h4><p>Each <span class="RktVar">action-expr</span> in a <span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._lexer))" class="RktStxLink" pltdoc="x">lexer</a></span> form can produce any
kind of value, but for many purposes, producing a <a name="(tech._token)"></a><span style="font-style: italic">token</span>
value is useful. Tokens are usually necessary for inter-operating with
a parser generated by <span class="RktSym">parser-tools/parser</span>, but tokens not be
the right choice when using <span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._lexer))" class="RktStxLink" pltdoc="x">lexer</a></span> in other situations.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex..rkt)._define-tokens))"></a><a name="(form._((lib._parser-tools/lex..rkt)._define-tokens))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._define-tokens))" class="RktStxLink" pltdoc="x">define-tokens</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">group-id</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">token-id</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">Binds <span class="RktVar">group-id</span> to the group of tokens being defined.  For
each <span class="RktVar">token-id</span>, a function
<span class="RktSym">token-</span><span class="RktVar">token-id</span> is created that takes any
value and puts it in a token record specific to <span class="RktVar">token-id</span>.
The token value is inspected using <span class="RktVar">token-id</span> and
<span class="RktSym"><a href="#(def._((lib._parser-tools/lex..rkt)._token-value))" class="RktValLink" pltdoc="x">token-value</a></span>.</div></p><p>A token cannot be named <span class="RktSym">error</span>, since
<span class="RktSym">error</span> it has special use in the parser.</p><p><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex..rkt)._define-empty-tokens))"></a><a name="(form._((lib._parser-tools/lex..rkt)._define-empty-tokens))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._define-empty-tokens))" class="RktStxLink" pltdoc="x">define-empty-tokens</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">group-id</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">token-id</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></p><p>Like <span class="RktSym"><a href="#(form._((lib._parser-tools/lex..rkt)._define-tokens))" class="RktStxLink" pltdoc="x">define-tokens</a></span>, except a each token constructor
<span class="RktSym">token-</span><span class="RktVar">token-id</span> takes no arguments and returns
<span class="RktPn">(</span><span class="RktSym"><a href="../reference/quote.html#(form._((quote._~23~25kernel)._quote))" class="RktStxLink" pltdoc="x">quote</a></span><span class="stt"> </span><span class="RktVar">token-id</span><span class="RktPn">)</span>.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex..rkt)._token-name))"></a><a name="(def._((lib._parser-tools/lex..rkt)._token-name))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(def._((lib._parser-tools/lex..rkt)._token-name))" class="RktValLink" pltdoc="x">token-name</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym"><a href="../reference/symbols.html#(def._((quote._~23~25kernel)._symbol~3f))" class="RktValLink" pltdoc="x">symbol?</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/Data-structure_Contracts.html#(def._((lib._racket/contract/private/misc..rkt)._or/c))" class="RktValLink" pltdoc="x">or/c</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="#(def._((lib._parser-tools/lex..rkt)._token~3f))" class="RktValLink" pltdoc="x">token?</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="../reference/symbols.html#(def._((quote._~23~25kernel)._symbol~3f))" class="RktValLink" pltdoc="x">symbol?</a></span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">Returns the name of a token that is represented either by a symbol
or a token structure.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex..rkt)._token-value))"></a><a name="(def._((lib._parser-tools/lex..rkt)._token-value))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(def._((lib._parser-tools/lex..rkt)._token-value))" class="RktValLink" pltdoc="x">token-value</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">t</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym"><a href="../reference/Data-structure_Contracts.html#(def._((lib._racket/contract/private/guts..rkt)._any/c))" class="RktValLink" pltdoc="x">any/c</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">t</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/Data-structure_Contracts.html#(def._((lib._racket/contract/private/misc..rkt)._or/c))" class="RktValLink" pltdoc="x">or/c</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="#(def._((lib._parser-tools/lex..rkt)._token~3f))" class="RktValLink" pltdoc="x">token?</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="../reference/symbols.html#(def._((quote._~23~25kernel)._symbol~3f))" class="RktValLink" pltdoc="x">symbol?</a></span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">Returns the value of a token that is represented either by a symbol
or a token structure, returning <span class="RktVal">#f</span> for a symbol token.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><span class="RktPn">(</span><a name="(dep._((lib._parser-tools/lex..rkt)._token~3f))"></a><a name="(def._((lib._parser-tools/lex..rkt)._token~3f))"></a><span title="Provided from: parser-tools/lex"><span class="RktSym"><a href="#(def._((lib._parser-tools/lex..rkt)._token~3f))" class="RktValLink" pltdoc="x">token?</a></span></span><span class="hspace">&nbsp;</span><span class="RktVar">v</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym"><a href="../reference/booleans.html#(def._((quote._~23~25kernel)._boolean~3f))" class="RktValLink" pltdoc="x">boolean?</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">v</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym"><a href="../reference/Data-structure_Contracts.html#(def._((lib._racket/contract/private/guts..rkt)._any/c))" class="RktValLink" pltdoc="x">any/c</a></span></td></tr></table></div><div class="SIntrapara">Returns <span class="RktVal">#t</span> if <span class="RktSym">val</span> is a
token structure, <span class="RktVal">#f</span> otherwise.</div></p><div class="navsetbottom"><span class="navleft"><form class="searchform"><input class="searchbox" style="color: #888;" type="text" value="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;5.0.2&quot;, &quot;../&quot;);" onfocus="this.style.color=&quot;black&quot;; this.style.textAlign=&quot;left&quot;; if (this.value == &quot;...search manuals...&quot;) this.value=&quot;&quot;;" onblur="if (this.value.match(/^ *$/)) { this.style.color=&quot;#888&quot;; this.style.textAlign=&quot;center&quot;; this.value=&quot;...search manuals...&quot;; }" /></form>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" pltdoc="x" onclick="return GotoPLTRoot(&quot;5.0.2&quot;);">top</a></span><span class="navright"><a href="index.html" title="backward to &quot;Parser Tools: lex and yacc-style Parsing&quot;" pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Parser Tools: lex and yacc-style Parsing&quot;" pltdoc="x">up</a>&nbsp;&nbsp;<a href="Parsers.html" title="forward to &quot;2 Parsers&quot;" pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>