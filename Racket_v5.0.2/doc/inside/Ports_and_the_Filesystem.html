<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text-html; charset=utf-8" /><title>13&nbsp;Ports and the Filesystem</title><link rel="stylesheet" type="text/css" href="../scribble.css" title="default" /><link rel="stylesheet" type="text/css" href="../racket.css" title="default" /><link rel="stylesheet" type="text/css" href="../scribble-style.css" title="default" /><script type="text/javascript" src="../scribble-common.js"></script></head><body id="doc-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist" style="margin-bottom: 1em;"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" pltdoc="x"><span style="font-weight: bold">Inside</span>:<span class="mywbr"> </span> Racket C API</a></td></tr></table></div><div class="tocviewsublistonly" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="overview.html" class="tocviewlink" pltdoc="x">Overview</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="im_values_types.html" class="tocviewlink" pltdoc="x">Values and Types</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="im_memoryalloc.html" class="tocviewlink" pltdoc="x">Memory Allocation</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="im_env.html" class="tocviewlink" pltdoc="x">Namespaces and Modules</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="Procedures.html" class="tocviewlink" pltdoc="x">Procedures</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="Evaluation.html" class="tocviewlink" pltdoc="x">Evaluation</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="exceptions.html" class="tocviewlink" pltdoc="x">Exceptions and Escape Continuations</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="threads.html" class="tocviewlink" pltdoc="x">Threads</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="config.html" class="tocviewlink" pltdoc="x">Parameterizations</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="contmarks.html" class="tocviewlink" pltdoc="x">Continuation Marks</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="im_encodings.html" class="tocviewlink" pltdoc="x">String Encodings</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="Bignums__Rationals__and_Complex_Numbers.html" class="tocviewlink" pltdoc="x">Bignums, Rationals, and Complex Numbers</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="" class="tocviewselflink" pltdoc="x">Ports and the Filesystem</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="Structures.html" class="tocviewlink" pltdoc="x">Structures</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="security.html" class="tocviewlink" pltdoc="x">Security Guards</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="Custodians.html" class="tocviewlink" pltdoc="x">Custodians</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="Miscellaneous_Utilities.html" class="tocviewlink" pltdoc="x">Miscellaneous Utilities</a></td></tr><tr><td align="right">18&nbsp;</td><td><a href="Flags_and_Hooks.html" class="tocviewlink" pltdoc="x">Flags and Hooks</a></td></tr><tr><td align="right"></td><td><a href="doc-index.html" class="tocviewlink" pltdoc="x">Index</a></td></tr></table></div></div></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><form class="searchform"><input class="searchbox" style="color: #888;" type="text" value="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;5.0.2&quot;, &quot;../&quot;);" onfocus="this.style.color=&quot;black&quot;; this.style.textAlign=&quot;left&quot;; if (this.value == &quot;...search manuals...&quot;) this.value=&quot;&quot;;" onblur="if (this.value.match(/^ *$/)) { this.style.color=&quot;#888&quot;; this.style.textAlign=&quot;center&quot;; this.value=&quot;...search manuals...&quot;; }" /></form>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" pltdoc="x" onclick="return GotoPLTRoot(&quot;5.0.2&quot;);">top</a></span><span class="navright"><a href="Bignums__Rationals__and_Complex_Numbers.html" title="backward to &quot;12 Bignums, Rationals, and Complex Numbers&quot;" pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Inside: Racket C API&quot;" pltdoc="x">up</a>&nbsp;&nbsp;<a href="Structures.html" title="forward to &quot;14 Structures&quot;" pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>13<tt>&nbsp;</tt><a name="(part._.Ports_and_the_.Filesystem)"></a>Ports and the Filesystem</h3><p>Ports are represented as Racket values with the types
<a href="im_values_types.html#(cpp._scheme_input_port_type)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_input_port_type</span></a> and <a href="im_values_types.html#(cpp._scheme_output_port_type)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_output_port_type</span></a>.  The
function <a href="#(cpp._scheme_read)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_read</span></a> takes an input port value and returns the
next S-expression from the port.  The function <a href="#(cpp._scheme_write)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_write</span></a>
takes an output port and a value and writes the value to the
port. Other standard low-level port functions are also provided, such
as <a href="#(cpp._scheme_getc)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_getc</span></a>.</p><p>File ports are created with <a href="#(cpp._scheme_make_file_input_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_file_input_port</span></a> and
<a href="#(cpp._scheme_make_file_output_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_file_output_port</span></a>; these functions take a <span class="stt">FILE
*</span> file pointer and return a Scheme port. Strings are read or written
with <a href="#(cpp._scheme_make_byte_string_input_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_byte_string_input_port</span></a>, which takes a
nul-terminated byte string, and
<a href="#(cpp._scheme_make_byte_string_output_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_byte_string_output_port</span></a>, which takes no arguments.
The contents of a string output port are obtained with
<a href="#(cpp._scheme_get_byte_string_output)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_get_byte_string_output</span></a>.</p><p>Custom ports, with arbitrary read/write handlers, are created with
<a href="#(cpp._scheme_make_input_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_input_port</span></a> and <a href="#(cpp._scheme_make_output_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_output_port</span></a>.</p><p>When opening a file for any reason using a name provided from Racket,
use <a href="#(cpp._scheme_expand_filename)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_expand_filename</span></a> to normalize the filename and
resolve relative paths.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">Scheme_Object*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_read)"></a><a name="(idx._(gentag._432._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_read)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_read</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara"><span class="RktSym"><a href="../reference/Reading.html#(def._((quote._~23~25kernel)._read))" class="RktValLink" pltdoc="x">read</a></span>s the next S-expression from the given input port.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_write)"></a><a name="(idx._(gentag._433._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_write)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_write</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">obj</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara"><span class="RktSym"><a href="../reference/Writing.html#(def._((quote._~23~25kernel)._write))" class="RktValLink" pltdoc="x">write</a></span>s the Scheme value <span style="font-style: italic">obj</span> to the given output port.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_write_w_max)"></a><a name="(idx._(gentag._434._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_write_w_max)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_write_w_max</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">obj</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">n</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_write)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_write</span></a>, but the printing is truncated to <span style="font-style: italic">n</span> bytes.
(If printing is truncated, the last bytes are printed as &ldquo;.&rdquo;.)</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_display)"></a><a name="(idx._(gentag._435._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_display)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_display</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">obj</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara"><span class="RktSym"><a href="../reference/Writing.html#(def._((quote._~23~25kernel)._display))" class="RktValLink" pltdoc="x">display</a></span>s the Racket value <span style="font-style: italic">obj</span> to the given output
port.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_display_w_max)"></a><a name="(idx._(gentag._436._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_display_w_max)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_display_w_max</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">obj</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">n</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_display)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_display</span></a>, but the printing is truncated to <span style="font-style: italic">n</span> bytes.
(If printing is truncated, the last three bytes are printed as &ldquo;.&rdquo;.)</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_write_byte_string)"></a><a name="(idx._(gentag._437._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_write_byte_string)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_write_byte_string</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">str</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">len</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Writes <span style="font-style: italic">len</span> bytes of <span style="font-style: italic">str</span> to the given output port.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_write_char_string)"></a><a name="(idx._(gentag._438._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_write_char_string)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_write_char_string</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">mzchar*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">str</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">len</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Writes <span style="font-style: italic">len</span> characters of <span style="font-style: italic">str</span> to the given output port.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">long</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_put_byte_string)"></a><a name="(idx._(gentag._439._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_put_byte_string)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_put_byte_string</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">const char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">who</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">str</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">d</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">len</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">rarely_block</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Writes <span style="font-style: italic">len</span> bytes of <span style="font-style: italic">str</span>, starting with the <span style="font-style: italic">d</span>th
character. Bytes are written to the given output port, and errors are
reported as from <span style="font-style: italic">who</span>.</div></p><p>If <span style="font-style: italic">rarely_block</span> is <span class="stt">0</span>, the write blocks until all <span style="font-style: italic">len</span>
bytes are written, possibly to an internal buffer. If
<span style="font-style: italic">rarely_block</span> is <span class="stt">2</span>, the write never blocks, and written
bytes are not buffered. If <span style="font-style: italic">rarely_block</span> is <span class="stt">1</span>, the write
blocks only until at least one byte is written (without buffering) or
until part of an internal buffer is flushed.</p><p>Supplying <span class="stt">0</span> for <span style="font-style: italic">len</span> corresponds to a buffer-flush
request. If <span style="font-style: italic">rarely_block</span> is <span class="stt">2</span>, the flush request is
non-blocking, and if <span style="font-style: italic">rarely_block</span> is <span class="stt">0</span>, it is blocking.
(A <span style="font-style: italic">rarely_block</span> of <span class="stt">1</span> is the same as <span class="stt">0</span> in this case.)</p><p>The result is <span class="stt">-1</span> if no bytes are written from <span style="font-style: italic">str</span> and
unflushed bytes remain in the internal buffer. Otherwise, the return
value is the number of written characters.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">long</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_put_char_string)"></a><a name="(idx._(gentag._440._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_put_char_string)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_put_char_string</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">const char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">who</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">str</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">d</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">len</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_put_byte_string)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_put_byte_string</span></a>, but for a <span class="stt">mzchar</span> string, and
without the non-blocking option.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">char*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_write_to_string)"></a><a name="(idx._(gentag._441._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_write_to_string)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_write_to_string</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">obj</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">len</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Prints the Racket value <span style="font-style: italic">obj</span> using <span class="RktSym"><a href="../reference/Writing.html#(def._((quote._~23~25kernel)._write))" class="RktValLink" pltdoc="x">write</a></span> to a newly
allocated string. If <span style="font-style: italic">len</span> is not <span class="stt">NULL</span>, <span class="stt">*</span><span style="font-style: italic">len</span> is
set to the length of the bytes string.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_write_to_string_w_max)"></a><a name="(idx._(gentag._442._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_write_to_string_w_max)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_write_to_string_w_max</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">obj</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">len</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">n</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_write_to_string)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_write_to_string</span></a>, but the string is truncated to
<span style="font-style: italic">n</span> bytes.  (If the string is truncated, the last three bytes are
&ldquo;.&rdquo;.)</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">char*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_display_to_string)"></a><a name="(idx._(gentag._443._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_display_to_string)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_display_to_string</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">obj</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">len</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Prints the Racket value <span style="font-style: italic">obj</span> using <span class="RktSym"><a href="../reference/Writing.html#(def._((quote._~23~25kernel)._display))" class="RktValLink" pltdoc="x">display</a></span> to a newly
allocated string. If <span style="font-style: italic">len</span> is not <span class="stt">NULL</span>, <span class="stt">*</span><span style="font-style: italic">len</span> is
set to the length of the string.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_display_to_string_w_max)"></a><a name="(idx._(gentag._444._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_display_to_string_w_max)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_display_to_string_w_max</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">obj</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">len</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">n</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_display_to_string)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_display_to_string</span></a>, but the string is truncated to
<span style="font-style: italic">n</span> bytes.  (If the string is truncated, the last three bytes are
&ldquo;.&rdquo;.)</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_debug_print)"></a><a name="(idx._(gentag._445._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_debug_print)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_debug_print</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">obj</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Prints the Racket value <span style="font-style: italic">obj</span> using <span class="RktSym"><a href="../reference/Writing.html#(def._((quote._~23~25kernel)._write))" class="RktValLink" pltdoc="x">write</a></span> to the main
thread&rsquo;s output port.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_flush_output)"></a><a name="(idx._(gentag._446._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_flush_output)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_flush_output</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">If <span style="font-style: italic">port</span> is a file port, a buffered data is written to the file.
Otherwise, there is no effect. <span style="font-style: italic">port</span> must be an output port.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_get_byte)"></a><a name="(idx._(gentag._447._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_get_byte)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_get_byte</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Get the next byte from the given input port. The result can be <span class="stt">EOF</span>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_getc)"></a><a name="(idx._(gentag._448._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_getc)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_getc</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Get the next character from the given input port (by decoding bytes as UTF-8).
  The result can be <span class="stt">EOF</span>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_peek_byte)"></a><a name="(idx._(gentag._449._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_peek_byte)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_peek_byte</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Peeks the next byte from the given input port.  The result can be <span class="stt">EOF</span>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_peekc)"></a><a name="(idx._(gentag._450._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_peekc)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_peekc</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Peeks the next character from the given input port (by decoding bytes as UTF-8).
  The result can be <span class="stt">EOF</span>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_peek_byte_skip)"></a><a name="(idx._(gentag._451._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_peek_byte_skip)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_peek_byte_skip</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">skip</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_peek_byte)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_peek_byte</span></a>, but with a skip count.  The result can be <span class="stt">EOF</span>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_peekc_skip)"></a><a name="(idx._(gentag._452._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_peekc_skip)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_peekc_skip</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">skip</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_peekc)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_peekc</span></a>, but with a skip count.  The result can be <span class="stt">EOF</span>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">long</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_get_byte_string)"></a><a name="(idx._(gentag._453._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_get_byte_string)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_get_byte_string</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">const char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">who</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">buffer</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">offset</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">size</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">only_avail</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">peek</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">peek_skip</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Gets multiple bytes at once from a port, reporting errors with the
name <span style="font-style: italic">who</span>. The <span style="font-style: italic">size</span> argument indicates the number of
requested bytes, to be put into the <span style="font-style: italic">buffer</span> array starting at
<span style="font-style: italic">offset</span>.  The return value is the number of bytes actually read,
or <span class="stt">EOF</span> if an end-of-file is encountered without reading any
bytes.</div></p><p>If <span style="font-style: italic">only_avail</span> is <span class="stt">0</span>, then the function blocks until
<span style="font-style: italic">size</span> bytes are read or an end-of-file is reached. If
<span style="font-style: italic">only_avail</span> is <span class="stt">1</span>, the function blocks only until at least
one byte is read. If <span style="font-style: italic">only_avail</span> is <span class="stt">2</span>, the function never
blocks. If <span style="font-style: italic">only_avail</span> is <span class="stt">-1</span>, the function blocks only
until at least one byte is read but also allows breaks (with the
guarantee that bytes are read or a break is raised, but not both).</p><p>If <span style="font-style: italic">peek</span> is non-zero, then the port is peeked instead of
read. The <span style="font-style: italic">peek_skip</span> argument indicates a portion of the input
stream to skip as a non-negative, exact integer (fixnum or bignum). In
this case, an <span style="font-style: italic">only_avail</span> value of <span class="stt">1</span> means to continue the
skip until at least one byte can be returned, even if it means
multiple blocking reads to skip bytes.</p><p>If <span style="font-style: italic">peek</span> is zero, then <span style="font-style: italic">peek_skip</span> should be either
<span class="stt">NULL</span> (which means zero) or the fixnum zero.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">long</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_get_char_string)"></a><a name="(idx._(gentag._454._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_get_char_string)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_get_char_string</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">const char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">who</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">buffer</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">offset</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">size</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">peek</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">peek_skip</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_get_byte_string)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_get_byte_string</span></a>, but for characters (by decoding
bytes as UTF-8), and without the non-blocking option.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">long</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_get_bytes)"></a><a name="(idx._(gentag._455._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_get_bytes)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_get_bytes</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">size</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">buffer</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">offset</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">For backward compatibility: calls <a href="#(cpp._scheme_get_byte_string)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_get_byte_string</span></a> in
essentially the obvious way with <span style="font-style: italic">only_avail</span> as <span class="stt">0</span>; if
<span style="font-style: italic">size</span> is negative, then it reads <span style="font-style: italic">-size</span> bytes with
<span style="font-style: italic">only_avail</span> as <span class="stt">1</span>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_ungetc)"></a><a name="(idx._(gentag._456._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_ungetc)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_ungetc</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">ch</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Puts the byte <span style="font-style: italic">ch</span> back as the next character to be read from the
given input port. The character need not have been read from
<span style="font-style: italic">port</span>, and <a href="#(cpp._scheme_ungetc)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_ungetc</span></a> can be called to insert up to five
characters at the start of <span style="font-style: italic">port</span>.</div></p><p>Use <a href="#(cpp._scheme_get_byte)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_get_byte</span></a> followed by <a href="#(cpp._scheme_ungetc)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_ungetc</span></a> only when
your program will certainly call <a href="#(cpp._scheme_get_byte)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_get_byte</span></a> again to
consume the byte. Otherwise, use <a href="#(cpp._scheme_peek_byte)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_peek_byte</span></a>, because some
a port may implement peeking and getting differently.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_byte_ready)"></a><a name="(idx._(gentag._457._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_byte_ready)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_byte_ready</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Returns 1 if a call to <a href="#(cpp._scheme_get_byte)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_get_byte</span></a> is guaranteed not to
block for the given input port.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_char_ready)"></a><a name="(idx._(gentag._458._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_char_ready)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_char_ready</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Returns 1 if a call to <a href="#(cpp._scheme_getc)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_getc</span></a> is guaranteed not to block
for the given input port.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_need_wakeup)"></a><a name="(idx._(gentag._459._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_need_wakeup)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_need_wakeup</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">fds</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Requests that appropriate bits are set in <span style="font-style: italic">fds</span> to specify which
file descriptors(s) the given input port reads from. (<span style="font-style: italic">fds</span> is
sortof a pointer to an <span class="stt">fd_set</span> struct; see
<a href="threads.html#(part._blockednonmainel)" pltdoc="x">Callbacks for Blocked Threads</a>.)</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">long</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_tell)"></a><a name="(idx._(gentag._460._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_tell)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_tell</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Returns the current read position of the given input port, or the
 current file position of the given output port.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">long</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_tell_line)"></a><a name="(idx._(gentag._461._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_tell_line)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_tell_line</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Returns the current read line of the given input port. If lines are
not counted, -1 is returned.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_count_lines)"></a><a name="(idx._(gentag._462._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_count_lines)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_count_lines</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Turns on line-counting for the given input port. To get accurate line
counts, call this function immediately after creating a port.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">long</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_set_file_position)"></a><a name="(idx._(gentag._463._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_set_file_position)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_set_file_position</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">pos</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Sets the file position of the given input or output port (from the
start of the file). If the port does not support position setting, an
exception is raised.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_close_input_port)"></a><a name="(idx._(gentag._464._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_close_input_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_close_input_port</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Closes the given input port.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_close_output_port)"></a><a name="(idx._(gentag._465._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_close_output_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_close_output_port</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Closes the given output port.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_get_port_file_descriptor)"></a><a name="(idx._(gentag._466._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_get_port_file_descriptor)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_get_port_file_descriptor</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">fd</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Fills <span class="stt">*</span><span style="font-style: italic">fd</span> with a file-descriptor value for <span style="font-style: italic">port</span> if
one is available (i.e., the port is a file-stream port and it is not
closed). The result is non-zero if the file-descriptor value is
available, zero otherwise. Under Windows, a &ldquo;file dscriptor&rdquo; is a
file <span class="stt">HANDLE</span>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">long</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_get_port_fd)"></a><a name="(idx._(gentag._467._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_get_port_fd)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_get_port_fd</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_get_port_file_descriptor)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_get_port_file_descriptor</span></a>, but a file
 descriptor or <span class="stt">HANDLE</span> is returned directly, and the result is
 <span class="stt">-1</span> if no file descriptor or <span class="stt">HANDLE</span> is available.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">long</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_get_port_socket)"></a><a name="(idx._(gentag._468._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_get_port_socket)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_get_port_socket</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">s</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Fills <span class="stt">*</span><span style="font-style: italic">s</span> with a socket value for <span style="font-style: italic">port</span> if one is
available (i.e., the port is a TCP port and it is not closed). The
result is non-zero if the socket value is available, zero
otherwise. Under Windows, a socket value has type <span class="stt">SOCKET</span>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">Scheme_Object*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_make_port_type)"></a><a name="(idx._(gentag._469._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_make_port_type)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_port_type</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">name</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Creates a new port subtype.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td colspan="5"><p><span class="stt">Scheme_Input_Port*</span></p></td></tr><tr><td><p><a name="(cpp._scheme_make_input_port)"></a><a name="(idx._(gentag._470._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_make_input_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_input_port</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">subtype</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">data</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">name</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Get_String_Fun</span><span class="hspace">&nbsp;</span><span style="font-style: italic">get_bytes_fun</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Peek_String_Fun</span><span class="hspace">&nbsp;</span><span style="font-style: italic">peek_bytes_fun</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Progress_Evt_Fun</span><span class="hspace">&nbsp;</span><span style="font-style: italic">progress_evt_fun</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Peeked_Read_Fun</span><span class="hspace">&nbsp;</span><span style="font-style: italic">peeked_read_fun</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_In_Ready_Fun</span><span class="hspace">&nbsp;</span><span style="font-style: italic">char_ready_fun</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Close_Input_Fun</span><span class="hspace">&nbsp;</span><span style="font-style: italic">close_fun</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Need_Wakeup_Input_Fun</span><span class="hspace">&nbsp;</span><span style="font-style: italic">need_wakeup_fun</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">must_close</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Creates a new input port with arbitrary control functions. The
<span style="font-style: italic">subtype</span> is an arbitrary value to distinguish the port&rsquo;s class.
The pointer <span style="font-style: italic">data</span> will be installed as the port&rsquo;s user data,
which can be extracted/set with the <a href="im_values_types.html#(cpp._.S.C.H.E.M.E_.I.N.P.O.R.T_.V.A.L)" class="RktStxLink" pltdoc="x"><span class="stt">SCHEME_INPORT_VAL</span></a> macro.
The <span style="font-style: italic">name</span> object is used as the port&rsquo;s name (for
<span class="RktSym"><a href="../reference/inspectors.html#(def._((quote._~23~25kernel)._object-name))" class="RktValLink" pltdoc="x">object-name</a></span> and as the default source name for
<span class="RktSym"><a href="../reference/Reading.html#(def._((quote._~23~25kernel)._read-syntax))" class="RktValLink" pltdoc="x">read-syntax</a></span>).</div></p><p>If <span style="font-style: italic">must_close</span> is non-zero, the new port will be registered with
the current custodian, and <span style="font-style: italic">close_fun</span> is guaranteed to be called
before the port is garbage-collected.</p><p>Although the return type of <a href="#(cpp._scheme_make_input_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_input_port</span></a> is
<span class="stt">Scheme_Input_Port*</span>, it can be cast into a <span class="stt">Scheme_Object*</span>.</p><p>The functions are as follows.</p><blockquote class="leftindent"><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">long</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-style: italic">get_bytes_fun</span></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Input_Port*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">buffer</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">offset</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">size</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">nonblock</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">unless</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Reads bytes into <span style="font-style: italic">buffer</span>, starting from <span style="font-style: italic">offset</span>, up to
<span style="font-style: italic">size</span> bytes (i.e., <span style="font-style: italic">buffer</span> is at least
<span style="font-style: italic">offset</span> plus <span style="font-style: italic">size</span> long). If <span style="font-style: italic">nonblock</span> is <span class="stt">0</span>,
then the function can block indefinitely, but it should return
when at least one byte of data is available. If <span style="font-style: italic">nonblock</span> is
<span class="stt">1</span>, the function should never block. If <span style="font-style: italic">nonblock</span> is
<span class="stt">2</span>, a port in unbuffered mode should return only bytes
previously forced to be buffered; other ports should treat a
<span style="font-style: italic">nonblock</span> of <span class="stt">2</span> like <span class="stt">1</span>. If <span style="font-style: italic">nonblock</span> is
<span class="stt">-1</span>, the function can block, but should enable breaks while
blocking. The function should return <span class="stt">0</span> if no bytes are ready
in non-blocking mode. It should return <span class="stt">EOF</span> if an end-of-file
is reached (and no bytes were read into <span style="font-style: italic">buffer</span>). Otherwise,
the function should return the number of read bytes. The function
can raise an exception to report an error.</div></p><p>The <span style="font-style: italic">unless</span> argument will be non-<span class="stt">NULL</span> only when
<span style="font-style: italic">nonblocking</span> is non-zero (except as noted below), and only if
the port supports progress events. If <span style="font-style: italic">unless</span> is
non-<span class="stt">NULL</span> and <span class="stt">SCHEME_CDR(</span><span style="font-style: italic">unless</span><span class="stt">)</span> is
non-<span class="stt">NULL</span>, the latter is a progress event specific to the
port. The <span style="font-style: italic">get_bytes_fun</span> function should return
<span class="stt">SCHEME_UNLESS_READY</span> instead of reading bytes if the event
in <span style="font-style: italic">unless</span> becomes ready before bytes can be read. In
particular, <span style="font-style: italic">get_bytes_fun</span> should check the event in
<span style="font-style: italic">unless</span> before taking any action, and it should check the
event in <span style="font-style: italic">unless</span> after any operation that may allow Racket
thread swaps. If the read must block, then it should unblock if
the event in <span style="font-style: italic">unless</span> becomes ready.</p><p>If <span class="stt">scheme_progress_evt_via_get</span> is used for
<span style="font-style: italic">progress_evt_fun</span>, then <span style="font-style: italic">unless</span> can be non-<span class="stt">NULL</span>
even when <span style="font-style: italic">nonblocking</span> is <span class="stt">0</span>. In all modes,
<span style="font-style: italic">get_bytes_fun</span> must call <span class="stt">scheme_unless_ready</span> to check
<span style="font-style: italic">unless_evt</span>.  Furthermore, after any potentially
thread-swapping operation, <span style="font-style: italic">get_bytes_fun</span> must call
<span class="stt">scheme_wait_input_allowed</span>, because another thread may be
attempting to commit, and <span style="font-style: italic">unless_evt</span> must be checked after
<span class="stt">scheme_wait_input_allowed</span> returns. To block, the port should
use <a href="threads.html#(cpp._scheme_block_until_unless)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_block_until_unless</span></a> instead of
<a href="threads.html#(cpp._scheme_block_until)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_block_until</span></a>.  Finally, in blocking mode,
<span style="font-style: italic">get_bytes_fun</span> must return after immediately reading data,
without allowing a Racket thread swap.</p></blockquote><blockquote class="leftindent"><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">long</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-style: italic">peek_bytes_fun</span></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Input_Port*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">buffer</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">offset</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">size</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">skip</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">nonblock</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">unless_evt</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Can be <span class="stt">NULL</span> to use a default implementation of peeking that
uses <span style="font-style: italic">get_bytes_fun</span>. Otherwise, the protocol is the same as
for <span style="font-style: italic">get_bytes_fun</span>, except that an extra <span style="font-style: italic">skip</span> argument
indicates the number of input elements to skip (but <span style="font-style: italic">skip</span>
does not apply to <span style="font-style: italic">buffer</span>). The <span style="font-style: italic">skip</span> value will be a
non-negative exact integer, either a fixnum or a bignum.</div></p></blockquote><blockquote class="leftindent"><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">Scheme_Object*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-style: italic">progress_evt_fun</span></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Input_Port*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Called to obtain a progress event for the port, such as for
<span class="RktSym"><a href="../reference/Byte_and_String_Input.html#(def._((quote._~23~25kernel)._port-progress-evt))" class="RktValLink" pltdoc="x">port-progress-evt</a></span>. This function can be <span class="stt">NULL</span> if the
port does not support progress events. Use
<span class="stt">scheme_progress_evt_via_get</span> to obtain a default implementation, in
which case <span style="font-style: italic">peeked_read_fun</span> should be
<span class="stt">scheme_peeked_read_via_get</span>, and <span style="font-style: italic">get_bytes_fun</span> and
<span style="font-style: italic">peek_bytes_fun</span> should handle <span style="font-style: italic">unless</span> as described
above.</div></p></blockquote><blockquote class="leftindent"><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-style: italic">peeked_read_fun</span></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Input_Port*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">amount</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">unless_evt</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">target_ch</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Called to commit previously peeked bytes, just like the sixth
argument to <span class="RktSym"><a href="../reference/customport.html#(def._((quote._~23~25kernel)._make-input-port))" class="RktValLink" pltdoc="x">make-input-port</a></span>. Use
<span class="stt">scheme_peeked_read_via_get</span> for the default implementation of
commits when <span style="font-style: italic">progress_evt_fun</span> is
<span class="stt">scheme_progress_evt_via_get</span>.</div></p></blockquote><blockquote class="leftindent"><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-style: italic">char_ready_fun</span></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Input_Port*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Returns <span class="stt">1</span> when a non-blocking <span style="font-style: italic">get_bytes_fun</span> will
return bytes or an <span class="stt">EOF</span>.</div></p></blockquote><blockquote class="leftindent"><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-style: italic">close_fun</span></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Input_Port*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Called to close the port. The port is not considered closed until
the function returns.</div></p></blockquote><blockquote class="leftindent"><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-style: italic">need_wakeup_fun</span></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Input_Port*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">fds</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Called when the port is blocked on a read; <span style="font-style: italic">need_wakeup_fun</span>
should set appropriate bits in <span style="font-style: italic">fds</span> to specify which file
descriptor(s) it is blocked on. The <span style="font-style: italic">fds</span> argument is
conceptually an array of three <span class="stt">fd_set</span> structs (one for
read, one for write, one for exceptions), but manipulate this
array using <a href="threads.html#(cpp._scheme_get_fdset)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_get_fdset</span></a> to get a particular element of
the array, and use <span class="stt">MZ_FD_XXX</span> instead of <span class="stt">FD_XXX</span> to
manipulate a single &ldquo;<span class="stt">fd_set</span>&rdquo;. Under Windows, the first
&ldquo;<span class="stt">fd_set</span>&rdquo; can also contain OS-level semaphores or other
handles via <a href="threads.html#(cpp._scheme_add_fd_handle)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_add_fd_handle</span></a>.</div></p></blockquote><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td colspan="5"><p><span class="stt">Scheme_Output_Port*</span></p></td></tr><tr><td><p><a name="(cpp._scheme_make_output_port)"></a><a name="(idx._(gentag._471._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_make_output_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_output_port</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">subtype</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">data</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">name</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Write_String_Evt_Fun</span><span class="hspace">&nbsp;</span><span style="font-style: italic">write_bytes_evt_fun</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Write_String_Fun</span><span class="hspace">&nbsp;</span><span style="font-style: italic">write_bytes_fun</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Out_Ready_Fun</span><span class="hspace">&nbsp;</span><span style="font-style: italic">char_ready_fun</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Close_Output_Fun</span><span class="hspace">&nbsp;</span><span style="font-style: italic">close_fun</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Need_Wakeup_Output_Fun</span><span class="hspace">&nbsp;</span><span style="font-style: italic">need_wakeup_fun</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Write_Special_Fun</span><span class="hspace">&nbsp;</span><span style="font-style: italic">write_special_fun</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Write_Special_Evt_Fun</span><span class="hspace">&nbsp;</span><span style="font-style: italic">write_special_evt_fun</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Write_Special_Fun</span><span class="hspace">&nbsp;</span><span style="font-style: italic">write_special_fun</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">must_close</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Creates a new output port with arbitrary control functions.  The
<span style="font-style: italic">subtype</span> is an arbitrary value to distinguish the port&rsquo;s class.
The pointer <span style="font-style: italic">data</span> will be installed as the port&rsquo;s user data,
which can be extracted/set with the <a href="im_values_types.html#(cpp._.S.C.H.E.M.E_.O.U.T.P.O.R.T_.V.A.L)" class="RktStxLink" pltdoc="x"><span class="stt">SCHEME_OUTPORT_VAL</span></a>
macro. The <span style="font-style: italic">name</span> object is used as the port&rsquo;s name.</div></p><p>If <span style="font-style: italic">must_close</span> is non-zero, the new port will be registered with
the current custodian, and <span style="font-style: italic">close_fun</span> is guaranteed to be called
before the port is garbage-collected.</p><p>Although the return type of <a href="#(cpp._scheme_make_output_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_output_port</span></a> is
<span class="stt">Scheme_Output_Port*</span>, it can be cast into a
<span class="stt">Scheme_Object*</span>.</p><p>The functions are as follows.</p><blockquote class="leftindent"><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">long</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-style: italic">write_bytes_evt_fun</span></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Output_Port*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">const char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">buffer</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">offset</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">size</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Returns an event that writes up to <span style="font-style: italic">size</span> bytes atomically
when event is chosen in a synchronization. Supply <span class="stt">NULL</span> if
bytes cannot be written atomically, or supply
<span class="stt">scheme_write_evt_via_write</span> to use the default
implementation in terms of <span class="stt">write_bytes_fun</span> (with
<span style="font-style: italic">rarely_block</span> as <span class="stt">2</span>).</div></p></blockquote><blockquote class="leftindent"><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">long</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-style: italic">write_bytes_fun</span></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Output_Port*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">const char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">buffer</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">offset</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">size</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">rarely_block</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">enable_break</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Write bytes from <span style="font-style: italic">buffer</span>, starting from <span style="font-style: italic">offset</span>, up to
<span style="font-style: italic">size</span> bytes (i.e., <span style="font-style: italic">buffer</span> is at least
<span style="font-style: italic">offset</span> plus <span style="font-style: italic">size</span> long). If <span style="font-style: italic">rarely_block</span> is <span class="stt">0</span>,
then the function can block indefinitely, and it can buffer
output. If <span style="font-style: italic">rarely_block</span> is <span class="stt">2</span>, the function should
never block, and it should not buffer output. If
<span style="font-style: italic">rarely_block</span> is <span class="stt">1</span>, the function should not buffer
data, and it should block only until writing at least one byte,
either from <span style="font-style: italic">buffer</span> or an internal buffer. The function
should return the number of bytes from <span style="font-style: italic">buffer</span> that were
written; when <span style="font-style: italic">rarely_block</span> is non-zero and bytes remain in
an internal buffer, it should return <span class="stt">-1</span>. The <span style="font-style: italic">size</span>
argument can be <span class="stt">0</span> when <span style="font-style: italic">rarely_block</span> is <span class="stt">0</span> for a
blocking flush, and it can be <span class="stt">0</span> if <span style="font-style: italic">rarely_block</span> is
<span class="stt">2</span> for a non-blocking flush.  If <span style="font-style: italic">enable_break</span> is true,
then it should enable breaks while blocking. The function can
raise an exception to report an error.</div></p></blockquote><blockquote class="leftindent"><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-style: italic">char_ready_fun</span></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Output_Port*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Returns <span class="stt">1</span> when a non-blocking <span style="font-style: italic">write_bytes_fun</span> will
write at least one byte or flush at least one byte from
the port&rsquo;s internal buffer.</div></p></blockquote><blockquote class="leftindent"><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-style: italic">close_fun</span></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Output_Port*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Called to close the port. The port is not considered closed until
the function returns. This function is allowed to block (usually
to flush a buffer) unless
<a href="#(cpp._scheme_close_should_force_port_closed)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_close_should_force_port_closed</span></a> returns a non-zero
result, in which case the function must return without blocking.</div></p></blockquote><blockquote class="leftindent"><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-style: italic">need_wakeup_fun</span></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Output_Port*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">fds</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Called when the port is blocked on a write; <span style="font-style: italic">need_wakeup_fun</span>
should set appropriate bits in <span style="font-style: italic">fds</span> to specify which file
descriptor(s) it is blocked on. The <span style="font-style: italic">fds</span> argument is
conceptually an array of three <span class="stt">fd_set</span> structs (one for
read, one for write, one for exceptions), but manipulate this
array using <a href="threads.html#(cpp._scheme_get_fdset)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_get_fdset</span></a> to get a particular element of
the array, and use <span class="stt">MZ_FD_XXX</span> instead of <span class="stt">FD_XXX</span> to
manipulate a single &ldquo;<span class="stt">fd_set</span>&rdquo;. Under Windows, the first
&ldquo;<span class="stt">fd_set</span>&rdquo; can also contain OS-level semaphores or other
handles via <a href="threads.html#(cpp._scheme_add_fd_handle)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_add_fd_handle</span></a>.</div></p></blockquote><blockquote class="leftindent"><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-style: italic">write_special_evt_fun</span></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Output_Port*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">v</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Returns an event that writes <span style="font-style: italic">v</span> atomically when event is
chosen in a synchronization. Supply <span class="stt">NULL</span> if specials cannot
be written atomically (or at all), or supply
<span class="stt">scheme_write_special_evt_via_write_special</span> to use the
default implementation in terms of <span class="stt">write_special_fun</span> (with
<span style="font-style: italic">non_block</span> as <span class="stt">1</span>).</div></p></blockquote><blockquote class="leftindent"><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-style: italic">write_special_fun</span></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Output_Port*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">v</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">non_block</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Called to write the special value <span style="font-style: italic">v</span> for
<span class="RktSym"><a href="../reference/Byte_and_String_Output.html#(def._((quote._~23~25kernel)._write-special))" class="RktValLink" pltdoc="x">write-special</a></span> (when <span style="font-style: italic">non_block</span> is <span class="stt">0</span>) or
<span class="RktSym"><a href="../reference/Byte_and_String_Output.html#(def._((quote._~23~25kernel)._write-special-avail*))" class="RktValLink" pltdoc="x">write-special-avail*</a></span> (when <span style="font-style: italic">non_block</span> is
<span class="stt">1</span>). If <span class="stt">NULL</span> is supplied instead of a function pointer,
then <span class="RktSym"><a href="../reference/Byte_and_String_Output.html#(def._((quote._~23~25kernel)._write-special))" class="RktValLink" pltdoc="x">write-special</a></span> and <span class="RktSym"><a href="../reference/Byte_and_String_Output.html#(def._((quote._~23~25kernel)._write-special-avail*))" class="RktValLink" pltdoc="x">write-special-avail*</a></span>
produce an error for this port.</div></p></blockquote><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">Scheme_Object*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_make_file_input_port)"></a><a name="(idx._(gentag._472._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_make_file_input_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_file_input_port</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">FILE*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">fp</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Creates a Scheme input file port from an ANSI C file pointer. The file
 must never block on reads.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">Scheme_Object*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_open_input_file)"></a><a name="(idx._(gentag._473._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_open_input_file)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_open_input_file</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">const char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">filename</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">const char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">who</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Opens <span style="font-style: italic">filename</span> for reading. In an exception is raised, the
 exception message uses <span style="font-style: italic">who</span> as the name of procedure that raised
 the exception.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td colspan="5"><p><span class="stt">Scheme_Object*</span></p></td></tr><tr><td><p><a name="(cpp._scheme_make_named_file_input_port)"></a><a name="(idx._(gentag._474._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_make_named_file_input_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_named_file_input_port</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">FILE*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">fp</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">name</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Creates a Racket input file port from an ANSI C file pointer. The file
 must never block on reads. The <span style="font-style: italic">name</span> argument is used as the
 port&rsquo;s name.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">Scheme_Object*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_open_output_file)"></a><a name="(idx._(gentag._475._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_open_output_file)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_open_output_file</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">const char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">filename</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">const char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">who</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Opens <span style="font-style: italic">filename</span> for writing in <span class="RktVal">'</span><span class="RktVal">truncate/replace</span> mode. If
 an exception is raised, the exception message uses <span style="font-style: italic">who</span> as the
 name of procedure that raised the exception.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">Scheme_Object*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_make_file_output_port)"></a><a name="(idx._(gentag._476._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_make_file_output_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_file_output_port</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">FILE*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">fp</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Creates a Racket output file port from an ANSI C file pointer. The
 file must never block on writes.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">Scheme_Object*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_make_fd_input_port)"></a><a name="(idx._(gentag._477._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_make_fd_input_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_fd_input_port</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">fd</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">name</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">regfile</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">win_textmode</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Creates a Racket input port for a file descriptor <span style="font-style: italic">fd</span>. Under
 Windows, <span style="font-style: italic">fd</span> can be a <span class="stt">HANDLE</span> for a stream, and it should
 never be a file descriptor from the C library or a WinSock socket.</div></p><p>The <span style="font-style: italic">name</span> object is used for the port&rsquo;s name. Specify a non-zero
 value for <span style="font-style: italic">regfile</span> only if the file descriptor corresponds to a
 regular file (which implies that reading never blocks, for example).</p><p>Under Windows, <span style="font-style: italic">win_textmode</span> can be non-zero to make trigger
 auto-conversion (at the byte level) of CRLF combinations to LF.</p><p>Closing the resulting port closes the file descriptor.</p><p>Instead of calling both <a href="#(cpp._scheme_make_fd_input_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_fd_input_port</span></a> and
 <a href="#(cpp._scheme_make_fd_output_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_fd_output_port</span></a> on the same file descriptor, call
 <a href="#(cpp._scheme_make_fd_output_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_fd_output_port</span></a> with a non-zero last
 argument. Otherwise, closing one of the ports causes the file
 descriptor used by the other to be closed as well.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">Scheme_Object*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_make_fd_output_port)"></a><a name="(idx._(gentag._478._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_make_fd_output_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_fd_output_port</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">fd</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">name</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">regfile</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">win_textmode</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">read_too</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Creates a Racket output port for a file descriptor <span style="font-style: italic">fd</span>. Under
 Windows, <span style="font-style: italic">fd</span> can be a <span class="stt">HANDLE</span> for a stream, and it should
 never be a file descriptor from the C library or a WinSock socket.</div></p><p>The <span style="font-style: italic">name</span> object is used for the port&rsquo;s name. Specify a non-zero
 value for <span style="font-style: italic">regfile</span> only if the file descriptor corresponds to a
 regular file (which implies that reading never blocks, for example).</p><p>Under Windows, <span style="font-style: italic">win_textmode</span> can be non-zero to make trigger
 auto-conversion (at the byte level) of CRLF combinations to LF.</p><p>Closing the resulting port closes the file descriptor.</p><p>If <span style="font-style: italic">read_too</span> is non-zero, the function produces multiple values
 (see <a href="Evaluation.html#(part._multiple)" pltdoc="x">Multiple Values</a>) instead of a single port. The first result is
 an input port for <span style="font-style: italic">fd</span>, and the second is an output port for
 <span style="font-style: italic">fd</span>. These ports are connected in that the file descriptor is
 closed only when both of the ports are closed.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_socket_to_ports)"></a><a name="(idx._(gentag._479._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_socket_to_ports)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_socket_to_ports</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">s</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">const char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">name</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">close</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object**</span><span class="hspace">&nbsp;</span><span style="font-style: italic">inp</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object**</span><span class="hspace">&nbsp;</span><span style="font-style: italic">outp</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Creates Racket input and output ports for a TCP socket <span style="font-style: italic">s</span>. The
 <span style="font-style: italic">name</span> argument supplies the name for the ports. If <span style="font-style: italic">close</span>
 is non-zero, then the ports assume responsibility for closing the
 socket. The resulting ports are written to <span style="font-style: italic">inp</span> and <span style="font-style: italic">outp</span>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">Scheme_Object*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_make_byte_string_input_port)"></a><a name="(idx._(gentag._480._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_make_byte_string_input_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_byte_string_input_port</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">str</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Creates a Racket input port from a byte string; successive
 <span class="RktSym"><a href="../reference/Byte_and_String_Input.html#(def._((quote._~23~25kernel)._read-char))" class="RktValLink" pltdoc="x">read-char</a></span>s on the port return successive bytes in the
 string.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">Scheme_Object*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_make_byte_string_output_port)"></a><a name="(idx._(gentag._481._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_make_byte_string_output_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_byte_string_output_port</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Creates a Racket output port; all writes to the port are kept in a byte string,
 which can be obtained with <a href="#(cpp._scheme_get_byte_string_output)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_get_byte_string_output</span></a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">char*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_get_byte_string_output)"></a><a name="(idx._(gentag._482._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_get_byte_string_output)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_get_byte_string_output</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Returns (in a newly allocated byte string) all data that has been
 written to the given string output port so far. (The returned string
 is nul-terminated.)</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">char*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_get_sized_byte_string_output)"></a><a name="(idx._(gentag._483._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_get_sized_byte_string_output)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_get_sized_byte_string_output</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">len</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Returns (in a newly allocated byte string) all data that has been
 written to the given string output port so far and fills in
 <span class="stt">*len</span> with the length of the string in bytes (not including the
 nul terminator).</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_pipe)"></a><a name="(idx._(gentag._484._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_pipe)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_pipe</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object**</span><span class="hspace">&nbsp;</span><span style="font-style: italic">read</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object**</span><span class="hspace">&nbsp;</span><span style="font-style: italic">write</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Creates a pair of ports, setting <span class="stt">*</span><span style="font-style: italic">read</span> and
 <span class="stt">*</span><span style="font-style: italic">write</span>; data written to <span class="stt">*</span><span style="font-style: italic">write</span> can be read
 back out of <span class="stt">*</span><span style="font-style: italic">read</span>.  The pipe can store arbitrarily many
 unread characters,</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_pipe_with_limit)"></a><a name="(idx._(gentag._485._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_pipe_with_limit)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_pipe_with_limit</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object**</span><span class="hspace">&nbsp;</span><span style="font-style: italic">read</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object**</span><span class="hspace">&nbsp;</span><span style="font-style: italic">write</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">limit</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_pipe)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_pipe</span></a> if <span style="font-style: italic">limit</span> is <span class="stt">0</span>. If <span style="font-style: italic">limit</span> is
 positive, creates a pipe that stores at most <span style="font-style: italic">limit</span> unread
 characters, blocking writes when the pipe is full.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">Scheme_Input_Port*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_input_port_record)"></a><a name="(idx._(gentag._486._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_input_port_record)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_input_port_record</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Returns the input-port record for <span style="font-style: italic">port</span>, which may be either a
raw-port object with type <a href="im_values_types.html#(cpp._scheme_input_port_type)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_input_port_type</span></a> or a structure
with the <span class="RktSym"><a href="../reference/portstructs.html#(def._((quote._~23~25kernel)._prop~3ainput-port))" class="RktValLink" pltdoc="x">prop:input-port</a></span> property.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td colspan="5"><p><span class="stt">Scheme_Output_Port*</span></p></td></tr><tr><td><p><a name="(cpp._scheme_output_port_record)"></a><a name="(idx._(gentag._487._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_output_port_record)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_output_port_record</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">port</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Returns the output-port record for <span style="font-style: italic">port</span>, which may be either a
raw-port object with type <a href="im_values_types.html#(cpp._scheme_output_port_type)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_output_port_type</span></a> or a structure
with the <span class="RktSym"><a href="../reference/portstructs.html#(def._((quote._~23~25kernel)._prop~3aoutput-port))" class="RktValLink" pltdoc="x">prop:output-port</a></span> property.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_file_exists)"></a><a name="(idx._(gentag._488._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_file_exists)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_file_exists</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">name</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Returns 1 if a file by the given name exists, 0 otherwise. If
<span style="font-style: italic">name</span> specifies a directory, FALSE is returned.
The <span style="font-style: italic">name</span> should be already expanded.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_directory_exists)"></a><a name="(idx._(gentag._489._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_directory_exists)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_directory_exists</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">name</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Returns 1 if a directory by the given name exists, 0 otherwise.  The
<span style="font-style: italic">name</span> should be already expanded.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">char*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_expand_filename)"></a><a name="(idx._(gentag._490._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_expand_filename)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_expand_filename</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">const char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">name</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">len</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">const char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">where</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">expanded</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">checks</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Cleanses the pathname <span style="font-style: italic">name</span> (see <span class="RktSym"><a href="../reference/Manipulating_Paths.html#(def._((quote._~23~25kernel)._cleanse-path))" class="RktValLink" pltdoc="x">cleanse-path</a></span>) and
resolves relative paths with respect to the current directory
parameter. The <span style="font-style: italic">len</span> argument is the length of the input string;
if it is -1, the string is assumed to be null-terminated.  The
<span style="font-style: italic">where</span> argument is used to raise an exception if there is an
error in the filename; if this is <span class="stt">NULL</span>, an error is not reported
and <span class="stt">NULL</span> is returned instead.  If <span style="font-style: italic">expanded</span> is not
<span class="stt">NULL</span>, *<span style="font-style: italic">expanded</span> is set to 1 if some expansion takes place,
or 0 if the input name is simply returned.</div></p><p>If <span style="font-style: italic">guards</span> is not <span class="stt">0</span>, then <a href="security.html#(cpp._scheme_security_check_file)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_security_check_file</span></a>
(see <a href="security.html" pltdoc="x">Security Guards</a>) is called with <span style="font-style: italic">name</span>, <span style="font-style: italic">where</span>, and
<span style="font-style: italic">checks</span> (which implies that <span style="font-style: italic">where</span> should never be
<span class="stt">NULL</span> unless <span style="font-style: italic">guards</span> is <span class="stt">0</span>). Normally, <span style="font-style: italic">guards</span>
should be <span class="stt">SCHEME_GUARD_FILE_EXISTS</span> at a minimum. Note that a
failed access check will result in an exception.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">char*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_expand_string_filename)"></a><a name="(idx._(gentag._491._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_expand_string_filename)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_expand_string_filename</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">name</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">const char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">where</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">expanded</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">checks</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <span class="stt">scheme_expand_string</span>, but given a <span style="font-style: italic">name</span> that can be a
character string or a path value.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">Scheme_Object*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_char_string_to_path)"></a><a name="(idx._(gentag._492._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_char_string_to_path)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_char_string_to_path</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">s</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Converts a Racket character string into a Racket path value.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">Scheme_Object*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_path_to_char_string)"></a><a name="(idx._(gentag._493._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_path_to_char_string)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_path_to_char_string</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">s</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Converts a Racket path value into a Racket character string.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">Scheme_Object*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_make_path)"></a><a name="(idx._(gentag._494._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_make_path)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_path</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">bytes</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Makes a path value given a byte string. The <span style="font-style: italic">bytes</span> string is copied.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">Scheme_Object*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_make_path_without_copying)"></a><a name="(idx._(gentag._495._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_make_path_without_copying)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_path_without_copying</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">bytes</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_make_path)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_path</span></a>, but the string is not copied.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">Scheme_Object*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_make_sized_path)"></a><a name="(idx._(gentag._496._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_make_sized_path)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_sized_path</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">bytes</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">len</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">copy</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Makes a path whose byte form has size <span style="font-style: italic">len</span>. A copy of <span style="font-style: italic">bytes</span>
is made if <span style="font-style: italic">copy</span> is not 0. The string <span style="font-style: italic">bytes</span> should contain
<span style="font-style: italic">len</span> bytes, and if <span style="font-style: italic">copy</span> is zero, <span style="font-style: italic">bytes</span> must have a
nul terminator in addition. If <span style="font-style: italic">len</span> is negative, then the
nul-terminated length of <span style="font-style: italic">bytes</span> is used for the length.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">Scheme_Object*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_make_sized_offset_path)"></a><a name="(idx._(gentag._497._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_make_sized_offset_path)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_sized_offset_path</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">bytes</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">d</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long</span><span class="hspace">&nbsp;</span><span style="font-style: italic">len</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">copy</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_make_sized_path)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_sized_path</span></a>, except the <span style="font-style: italic">len</span> bytes start
from position <span style="font-style: italic">d</span> in <span style="font-style: italic">bytes</span>. If <span style="font-style: italic">d</span> is non-zero, then
<span style="font-style: italic">copy</span> must be non-zero.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">char*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_build_mac_filename)"></a><a name="(idx._(gentag._498._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_build_mac_filename)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_build_mac_filename</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">FSSpec*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">spec</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">isdir</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Mac OS X only: Converts an <span class="stt">FSSpec</span> record (defined by Mac OS X)
into a pathname string. If <span style="font-style: italic">spec</span> contains only directory
information (via the <span class="stt">vRefNum</span> and <span class="stt">parID</span> fields),
<span style="font-style: italic">isdir</span> should be <span class="stt">1</span>, otherwise it should be <span class="stt">0</span>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_mac_path_to_spec)"></a><a name="(idx._(gentag._499._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_mac_path_to_spec)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_mac_path_to_spec</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">const char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">filename</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">FSSpec*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">spec</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">type</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Mac OS X only: Converts a pathname into an <span class="stt">FSSpec</span> record
(defined by Mac OS X), returning <span class="stt">1</span> if successful and <span class="stt">0</span>
otherwise. If <span style="font-style: italic">type</span> is not <span class="stt">NULL</span> and <span style="font-style: italic">filename</span> is a
file that exists, <span style="font-style: italic">type</span> is filled with the file&rsquo;s four-character
Mac OS X type. If <span style="font-style: italic">type</span> is not <span class="stt">NULL</span> and <span style="font-style: italic">filename</span> is
not a file that exists, <span style="font-style: italic">type</span> is filled with <span class="stt">0</span>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">char*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_os_getcwd)"></a><a name="(idx._(gentag._500._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_os_getcwd)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_os_getcwd</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">buf</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">buflen</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">actlen</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">noexn</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Gets the <a name="(idx._(gentag._501._(lib._scribblings/inside/inside..scrbl)))"></a>current working directory according to the
operating system. This is separate from Racket&rsquo;s current directory
parameter.</div></p><p>The directory path is written into <span style="font-style: italic">buf</span>, of length <span style="font-style: italic">buflen</span>,
if it fits. Otherwise, a new (collectable) string is allocated for the
directory path. If <span style="font-style: italic">actlen</span> is not <span class="stt">NULL</span>, *<span style="font-style: italic">actlen</span> is
set to the length of the current directory path. If <span style="font-style: italic">noexn</span> is
no 0, then an exception is raised if the operation fails.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_os_setcwd)"></a><a name="(idx._(gentag._502._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_os_setcwd)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_os_setcwd</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">buf</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">noexn</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Sets the current working directory according to the operating system. This
is separate from Racket&rsquo;s current directory parameter.</div></p><p>If <span style="font-style: italic">noexn</span> is not 0, then an exception is raised if the operation
fails.</p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">char*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_format)"></a><a name="(idx._(gentag._503._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_format)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_format</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">mzchar*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">format</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">flen</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">argc</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object**</span><span class="hspace">&nbsp;</span><span style="font-style: italic">argv</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">rlen</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Creates a string like Racket&rsquo;s <span class="RktSym"><a href="../reference/Writing.html#(def._((quote._~23~25kernel)._format))" class="RktValLink" pltdoc="x">format</a></span> procedure, using the
format string <span style="font-style: italic">format</span> (of length <span style="font-style: italic">flen</span>) and the extra
arguments specified in <span style="font-style: italic">argc</span> and <span style="font-style: italic">argv</span>. If <span style="font-style: italic">rlen</span> is not
<span class="stt">NULL</span>, <span class="stt">*</span><span style="font-style: italic">rlen</span> is filled with the length of the
resulting string.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_printf)"></a><a name="(idx._(gentag._504._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_printf)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_printf</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">format</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">flen</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">argc</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object**</span><span class="hspace">&nbsp;</span><span style="font-style: italic">argv</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Writes to the current output port like Racket&rsquo;s <span class="RktSym"><a href="../reference/Writing.html#(def._((quote._~23~25kernel)._printf))" class="RktValLink" pltdoc="x">printf</a></span>
procedure, using the format string <span style="font-style: italic">format</span> (of length <span style="font-style: italic">flen</span>)
and the extra arguments specified in <span style="font-style: italic">argc</span> and <span style="font-style: italic">argv</span>.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">char*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_format_utf8)"></a><a name="(idx._(gentag._505._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_format_utf8)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_format_utf8</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">format</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">flen</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">argc</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object**</span><span class="hspace">&nbsp;</span><span style="font-style: italic">argv</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">long*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">rlen</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_format)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_format</span></a>, but takes a UTF-8-encoding byte string.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_printf_utf8)"></a><a name="(idx._(gentag._506._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_printf_utf8)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_printf_utf8</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-style: italic">format</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">flen</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-style: italic">argc</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object**</span><span class="hspace">&nbsp;</span><span style="font-style: italic">argv</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#(cpp._scheme_printf)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_printf</span></a>, but takes a UTF-8-encoding byte string.</div></p><p><div class="SIntrapara"><table cellspacing="0" class="boxed"><tr><td><table cellspacing="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_close_should_force_port_closed)"></a><a name="(idx._(gentag._507._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#(cpp._scheme_close_should_force_port_closed)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_close_should_force_port_closed</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">This function must be called by the close function for a port created
 with <a href="#(cpp._scheme_make_output_port)" class="RktStxLink" pltdoc="x"><span class="stt">scheme_make_output_port</span></a>.</div></p><div class="navsetbottom"><span class="navleft"><form class="searchform"><input class="searchbox" style="color: #888;" type="text" value="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;5.0.2&quot;, &quot;../&quot;);" onfocus="this.style.color=&quot;black&quot;; this.style.textAlign=&quot;left&quot;; if (this.value == &quot;...search manuals...&quot;) this.value=&quot;&quot;;" onblur="if (this.value.match(/^ *$/)) { this.style.color=&quot;#888&quot;; this.style.textAlign=&quot;center&quot;; this.value=&quot;...search manuals...&quot;; }" /></form>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" pltdoc="x" onclick="return GotoPLTRoot(&quot;5.0.2&quot;);">top</a></span><span class="navright"><a href="Bignums__Rationals__and_Complex_Numbers.html" title="backward to &quot;12 Bignums, Rationals, and Complex Numbers&quot;" pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Inside: Racket C API&quot;" pltdoc="x">up</a>&nbsp;&nbsp;<a href="Structures.html" title="forward to &quot;14 Structures&quot;" pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>